<!--
MIT License

Copyright (c) [2024] [Ashwin Natarajan]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="pageTitle">Pits n' Giggles</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Bangers&display=swap"
        rel="stylesheet">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">

    <style>
        /* Your existing styles */
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            /* Black background */
            color: #fdd835;
            /* Gold text */
            position: relative;
        }

        .top-section {
            display: flex;
            justify-content: space-around;
            align-items: stretch;
            gap: 20px;
            margin-top: 20px;
            max-height: 300px;
            overflow: hidden;
            margin-bottom: 1px;
            /* Adjust the margin-bottom as needed */
        }

        .weather-box,
        .race-info-box,
        .time-box {
            flex: 1;
            padding: 1px;
            background-color: #2e2e2e;
            /* Dark grey for Gotham feel */
            border: 2px solid #fdd835;
            /* Highlighted border in gold */
            border-radius: 10px;
            color: #fdd835;
            /* Text in gold */
            font-size: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
            line-height: 1;
        }

        #settingsButton {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            color: #fdd835; /* Gold color */
            font-size: 24px;
            cursor: pointer;
            z-index: 10;  /* Ensure button is on top */
        }

        #settingsButton:hover {
            color: #fff; /* White color on hover */
        }

        .race-info-box {
            line-height: 0.5;
        }

        table {
            width: 100%;
            table-layout: fixed;
            margin: 20px 0;
            background-color: #000;
            /* Black background */
            color: #fdd835;
            /* Gold text */
            border-spacing: 0;
            font-size: 24px;
        }

        th,
        td {
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #2e2e2e;
            /* Dark grey row separation */
        }

        th {
            background-color: #2e2e2e;
            /* Dark grey header background */
            color: #fdd835;
            /* Gold header text */
            font-weight: 700;
        }

        tbody tr:nth-child(even) {
            background-color: #1a1a1a;
            /* Darker shade for even rows */
        }

        .player-row td {
            font-weight: bold;
            border-color: #fdd835;
            /* Gold border */
        }

        .player-row td:first-child {
            border-left: 2px solid #fdd835;
            /* Left border on the first cell */
        }

        .player-row td:last-child {
            border-right: 2px solid #fdd835;
            /* Right border on the last cell */
        }

        .player-row td {
            border-top: 2px solid #fdd835 !important;
            /* Top border on all cells */
            border-bottom: 2px solid #fdd835 !important;
            /* Bottom border on all cells */
        }

        .fastest-lap {
            background-color: #E829F1 !important;
            /* Purple for fastest lap */
            color: #fff !important;
            /* White text for contrast */
        }

        .dnf {
            background-color: #771010 !important;
            /* Red for DNF */
            color: #fff !important;
            /* White text for contrast */
        }

        .dsq {
            background-color: #000000 !important;
            /* Black for DSQ */
            color: #fff !important;
            /* White text for contrast */
        }

        .drs-active {
            color: #28a745 !important;
            /* Green font color for DRS active, no background change */
        }

        /* Remove link styling */
        .motivationLink {
            color: #fdd835;
            /* Text in gold */
            cursor: pointer;
            text-decoration: underline;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Add background opacity */
            background-color: rgba(31, 30, 30, 0.9);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #181717;
            padding: 20px;
            border-radius: 10px;
            text-align: center;

            /* Set width to 80% of the viewport width */
            width: 80%;

            /* Set max height to 80% of the viewport height */
            max-height: 80vh;

            /* Set overflow-y to auto to enable scrolling if the content exceeds the max height */
            overflow-y: auto;

            /* Change font color to standard gold */
            color: #fdd835;
            z-index: 1000;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .accordion {
            overflow: hidden;
            margin-bottom: 10px;
        }

        .accordion-title {
            background-color: #2e2e2e;
            /* Dark grey header background */
            color: #fdd835;
            /* Gold header text */
            cursor: pointer;
            padding: 14px;
            width: 100%;
            text-align: center;
            border: none;
            outline: none;
            transition: background-color 0.3s;
            font-size: larger;
            font-family: 'Roboto', sans-serif;
        }

        .accordion-content {
            padding: 0 18px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
            width: 100%;
        }

        .graph-canvas {
            width: 1400px !important;
            /* height: 900px !important; */
            align-items: center;
            margin: auto;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            z-index: 9999;
        }

        .settings-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Roboto', sans-serif;
            font-size: 24px;
            color: #fdd835;
        }

        .settings-table td,
        .settings-table th {
            border: 1px solid #fdd835;
            padding: 10px;
            text-align: center; /* Default alignment for cells */
        }

        /* Align all cells in the first column to the right */
        .settings-table td:nth-child(1),
        .settings-table th:nth-child(1) {
            text-align: right;
            padding-right: 10px; /* Adds a bit of space between text and cell border */
        }

        /* Align all cells in the second column to the left */
        .settings-table td:nth-child(2),
        .settings-table th:nth-child(2) {
            text-align: left;
            padding-left: 10px; /* Adds a bit of space between text and cell border */
        }

        /* Style for the team name input */
        .team-name-input {
            width: 100%;
            height: 100%;
            padding: 8px;
            font-family: 'Roboto', sans-serif;
            font-size: 20px;
            color: #fdd835;
            background-color: #2e2e2e;
            border: 1px solid #fdd835;
            border-radius: 5px;
        }

        /* Apply button styling */
        .apply-button {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #fdd835;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .apply-button:hover {
            background-color: #e5c22e;
        }


    </style>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@10"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/4.4.1/socket.io.min.js"></script>
</head>

<body>
    <div class="top-section">
        <div class="weather-box">
            <!-- Weather table -->
            <table id="weatherTable">
                <thead>
                    <tr>
                        <th>Time Offset</th>
                        <th>Rain Probability</th>
                        <th>Weather</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div class="race-info-box">
            <h2 id="tableTitle">F1 Telemetry Live</h2>
            <table>
                <tr>
                    <td>Track Temperature</td>
                    <td id="trackTemperature"></td>
                </tr>
                <tr>
                    <td>Air Temperature</td>
                    <td id="airTemperature"></td>
                </tr>
                <tr>
                    <td>Lap</td>
                    <td id="lapInformation"></td>
                </tr>
                <tr id="sessionTimeLeftRow">
                    <td>Session Time Left</td>
                    <td id="sessionTimeLeft"></td>
                </tr>
                <tr>
                    <td colspan="2">
                        <a href="#" id="getRaceInfo" class="motivationLink">Get Race Information</a>
                    </td>
                </tr>
                <tr id="saveTelemetryLinkRow">
                    <td colspan="2">
                        <a href="#" id="saveTelemetryLink" class="motivationLink">Save telemetry packet capture</a>
                    </td>
                </tr>
            </table>
        </div>
        <div class="time-box">
            <button id="settingsButton">⚙️</button>
            <h2>Other info</h2>
            <table>
                <tr>
                    <td id="localTimeNameLink" class="motivationLink">Local Time (24H)</td>
                    <td id="localTimeValueLink" class="motivationLink"></td>
                </tr>
                <tr>
                    <td>Fastest Lap Overall</td>
                    <td id="fastestLapOverall"></td>
                </tr>
                <tr>
                    <td>Pit Lane Speed Limit</td>
                    <td id="pitSpeedLimit"></td>
                </tr>
            </table>
        </div>
    </div>

    <table id="raceTable">
        <thead>
            <tr>
                <th>Position</th>
                <th>Driver</th>
                <th id="deltaLink" class="motivationLink">Delta</th>
                <th>ERS</th>
                <th>Warnings</th>
                <th id="bestLapLink" class="motivationLink">Best</th>
                <th id="lastLapLink" class="motivationLink">Last</th>
                <th id="tyreInfoLink" class="motivationLink">Tyre Info</th>
                <th id="wearPredictionLink" class="motivationLink">Wear Prediction</th>
                <th>Wing Damage</th>
                <th>Fuel Rates</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <div id="driverInfoModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('driverInfoModal')">&times;</span>
            <h2 id="modalTitle">Driver Information</h2>
            <div id="modalContent" style="height: 90vh; overflow-y: auto;"></div>
        </div>
    </div>

    <script>
        // Init globals
        let is24HourFormat;
        let relativeDelta;
        let lastLapAbsoluteFormat;
        let bestLapAbsoluteFormat;
        let tyreWearAverageFormat;
        let myTeamName;

        // Check if delta column needs to be displayed
        const shouldHideDeltaColumn = {{ live_data_mode | tojson | safe }};
        const shouldHidePredictionColumn = !{{ live_data_mode | tojson | safe }};
        const shouldHideFuelColumn = !{{ live_data_mode | tojson | safe }};
        const shouldHideLastLapColumn = !{{ live_data_mode | tojson | safe }};

        function getTeamName(teamId) {
            if ("MY_TEAM" == teamId) {
                return myTeamName;
            } else {
                return teamId;
            }
        }

        function formatLapTime(milliseconds) {
            // Check if the input is 0 or null
            if (milliseconds === 0 || milliseconds === null) {
                return "---";
            }
            var minutes = Math.floor(milliseconds / 60000);
            var seconds = Math.floor((milliseconds % 60000) / 1000);
            var millisecondsPart = milliseconds % 1000;
            return minutes.toString().padStart(2, '0') + ":" +
                seconds.toString().padStart(2, '0') + "." +
                millisecondsPart.toString().padStart(3, '0'); // Ensure it's 3 digits
        }

        function formatLapDelta(lapTime, playerLapTime, isPlayer) {

            function formatDelta(delta) {
                // Determine the sign
                const sign = delta >= 0 ? '+' : '-';

                // Get the absolute value of delta for formatting
                const absDelta = Math.abs(delta);

                // Calculate seconds and milliseconds
                const seconds = Math.floor(absDelta / 1000);
                const milliseconds = absDelta % 1000;

                // Format the string as "±seconds.milliseconds"
                return sign + seconds + '.' + milliseconds.toString().padStart(3, '0'); // Ensure milliseconds are 3 digits
            }

            if (isPlayer) {
                return formatLapTime(playerLapTime);
            }

            if (lapTime === 0 || lapTime === null) {
                return "---";
            }

            if(playerLapTime === 0 || playerLapTime === null) {
                // player has not set a lap yet. so show absolute value
                return formatLapTime(lapTime);
            }

            return formatDelta(lapTime - playerLapTime);
        }

        function showToast(message) {
            // Create a new div element for the toast
            var toast = document.createElement('div');
            toast.classList.add('toast');

            // Set the message content
            toast.innerText = message;

            // Append the toast to the document body
            document.body.appendChild(toast);

            // Show the toast
            toast.style.opacity = 1;

            // Hide the toast after 3 seconds
            setTimeout(function() {
                toast.style.opacity = 0;
                // Remove the toast from the document after it fades out
                setTimeout(function() {
                document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }

        function formatFloatWithTwoDecimals(floatNumber) {
            if (typeof floatNumber !== 'number' || isNaN(floatNumber)) {
                console.error('Invalid input. Please provide a valid number.');
                return null;
            }

            // Use toFixed to round to two decimal places and convert to string
            return floatNumber.toFixed(2);
        }

        function formatFloatWithTwoDecimalsSigned(floatNumber) {
            if (typeof floatNumber !== 'number' || isNaN(floatNumber)) {
                console.error('Invalid input. Please provide a valid number.');
                return null;
            }

            // Use toFixed to round to two decimal places and convert to string
            const floatStr = floatNumber.toFixed(2);
            if (floatNumber >= 0.0) {
                return '+' + floatStr;
            } else {
                return floatStr;
            }
        }

        function getPlayerPosition(data) {
            let tableEntries = data["table-entries"];
            let playerPosition = null;

            for (let i = 0; i < tableEntries.length; i++) {
                let entry = tableEntries[i];
                const driverInfo = entry["driver-info"];
                if (driverInfo["is-player"]) {
                    playerPosition = driverInfo["position"];
                    break; // Breaks out of the loop once player position is found
                }
            }

            return playerPosition;
        }

        function getRelevantRaceTableRows(data) {

            if (data["table-entries"].length == 0) {
                return [];
            }
            if (data["is-spectating"] || data["race-ended"]) {
                return data["table-entries"];
            }
            const numAdjacentCars = {{ num_adjacent_cars }};
            const totalCars = data["table-entries"].length;
            const playerPosition = getPlayerPosition(data);
            relevantPositions = getAdjacentPositions(playerPosition, totalCars, numAdjacentCars);

            const lowerIndex = relevantPositions[0] - 1;
            const upperIndex = relevantPositions[relevantPositions.length -1];
            return data["table-entries"].slice(lowerIndex, upperIndex);
        }

        function displayData(data) {
            const gameYear = "f1-game-year" in data ? data["f1-game-year"] : 2023;
            if ('table-entries' in data) {
                updateRaceTable(getRelevantRaceTableRows(data), gameYear);
            }
            updateGlobalInfo(data["circuit"], data["event-type"], data["track-temperature"], data["air-temperature"],
                data["current-lap"], data["total-laps"], data["safety-car-status"], data["fastest-lap-overall"],
                data["pit-speed-limit"], data["session-time-left"], {{ packet_capture_enabled | tojson }});
            updateWeatherTable(data["weather-forecast-samples"]);
        }

        function fetchDataAndDisplay() {
            fetch("telemetry-info")
                .then(response => response.json())
                .then(data => {
                    displayData(data);
                })
                .catch (error => {
                    console.error('Error fetching data:', error);
                });
        }

        function updateWeatherTable(weatherData) {
            const weatherTableBody = document.querySelector('#weatherTable tbody');
            weatherTableBody.innerHTML = '';

            let iterationCount = 0; // Counter to track the number of iterations
            const maxWeatherSamples = 5;
            weatherData.forEach(data => {
                if (iterationCount < maxWeatherSamples) {
                    const row = weatherTableBody.insertRow();
                    row.insertCell().textContent = data["time-offset"];
                    row.insertCell().textContent = data["rain-probability"];
                    row.insertCell().textContent = data["weather"];

                    iterationCount++; // Increment the counter after each iteration
                } else {
                    // Break out of the loop if the maximum iterations (5) is reached
                    return;
                }
            });
        }

        function updateRaceTable(entries, gameYear) {

            function truncateName(name) {

                const maxLength = 25;
                if (name.length > maxLength) {
                    return name.substring(0, maxLength - 3) + '...';
                } else {
                    return name;
                }
            }

            function getMaxTyreWear(wearData) {
                const relevantKeys = {
                    "front-left-wear": "FL",
                    "front-right-wear": "FR",
                    "rear-left-wear": "RL",
                    "rear-right-wear": "RR"
                };

                let maxKey = null;
                let maxValue = -Infinity;

                // Iterate only through relevant keys
                for (const key in relevantKeys) {
                    if (key in wearData && wearData[key] > maxValue) {
                        maxValue = wearData[key];
                        maxKey = key;
                    }
                }

                // Return the result as a JSON object with max-key shortened and max-wear
                return {
                    "max-key": relevantKeys[maxKey],  // Use the shortened version
                    "max-wear": maxValue
                };
            }

            function addPositionInfo(row, driverInfo) {

                const positionCell = row.insertCell();
                positionCell.textContent = driverInfo["position"];
            }

            function addNameInfo(row, driverInfo) {

                // Create a clickable link for the driver's name
                const nameCell = row.insertCell();
                const nameLink = document.createElement('a');
                nameLink.innerHTML =    `${truncateName(driverInfo["name"])}` +
                                        `<br>` +
                                        `${truncateName(getTeamName(driverInfo["team"]))}`;
                nameLink.href = '#'; // Set a placeholder href value

                // Get the computed style of the row and apply it to the hyperlink
                const rowStyles = window.getComputedStyle(row);
                nameLink.style.color = rowStyles.getPropertyValue('color');
                nameLink.style.fontFamily = rowStyles.getPropertyValue('font-family');

                nameLink.style.textDecoration = 'underline'; // Add standard link underline
                nameLink.onclick = function () {
                    handleDriverInfoClick(driverInfo["index"]);
                };
                nameCell.appendChild(nameLink);
                return nameLink;
            }

            function addDeltaInfo(row, deltaInfo) {

                if (!shouldHideDeltaColumn) {
                    if (relativeDelta) {
                        row.insertCell().textContent = deltaInfo["delta"];
                    } else {
                        row.insertCell().textContent = deltaInfo["delta-to-leader"];
                    }
                }
            }

            function addErsInfo(row, ersInfo) {
                if (gameYear == 23) {
                    row.insertCell().textContent = ersInfo["ers-percent"];
                } else {
                    if ("ers-mode" in ersInfo) {
                        row.insertCell().innerHTML = `${ersInfo["ers-percent"]}<br>${ersInfo["ers-mode"]}`;
                    } else {
                        row.insertCell().textContent = ersInfo["ers-percent"];
                    }
                }
            }

            function addWarningsPensInfo(row, warnsPensInfo) {

                const warningsPensCell = row.insertCell();
                const dtPlusSg = warnsPensInfo["num-dt"] + "DT + " +
                    warnsPensInfo["num-sg"] + "SG";

                warningsPensCell.innerHTML =
                    `Pens: ${warnsPensInfo["time-penalties"]} sec<br>` +
                    `Warns: ${warnsPensInfo["corner-cutting-warnings"]}<br>` +
                    `${dtPlusSg}`;
            }

            function addBestLapInfo(row, lapInfo, isPlayer, isSpectating) {

                if (bestLapAbsoluteFormat || isSpectating) {
                    const lapStr = formatLapTime(lapInfo["best-lap-ms"]);
                    if (gameYear == 23) {
                        row.insertCell().textContent = lapStr;
                    } else {
                        let speedTrapValue;
                        if (lapInfo["speed-trap-record-kmph"] != null) {
                            speedTrapValue = formatFloatWithTwoDecimals(
                                lapInfo["speed-trap-record-kmph"]) + ' kmph';
                        } else {
                            speedTrapValue = "---";
                        }
                        row.insertCell().innerHTML = `
                            ${formatLapTime(lapInfo["best-lap-ms"])}<br>
                            ${speedTrapValue}
                        `;
                    }
                } else {
                    const lapDeltaStr = formatLapDelta(lapInfo["best-lap-ms"],
                            lapInfo["best-lap-ms-player"], isPlayer);
                    if (gameYear == 23) {
                        row.insertCell().textContent = lapDeltaStr;
                    } else {
                        let speedTrapValue;
                        if (lapInfo["speed-trap-record-kmph"] != null) {
                            speedTrapValue = formatFloatWithTwoDecimals(lapInfo["speed-trap-record-kmph"]) + ' kmph';
                        } else {
                            speedTrapValue = "---";
                        }
                        row.insertCell().innerHTML = `
                            ${lapDeltaStr}<br>
                            ${speedTrapValue}
                        `;
                    }
                }
            }

            function addLastLapInfo(row, lapInfo, isPlayer, isSpectating) {

                if (!shouldHideLastLapColumn) {
                    if (lastLapAbsoluteFormat || isSpectating) {
                        row.insertCell().textContent = formatLapTime(lapInfo["best-lap-ms"]);
                    } else {
                        row.insertCell().textContent = formatLapDelta(lapInfo["last-lap-ms"],
                            lapInfo["last-lap-ms-player"], isPlayer);;
                    }
                }
            }

            function addCurrTyreInfo(row, tyreInfoData) {

                function getTyreCompoundStr(visualTyreCompound, actualTyreCompound) {

                    if (visualTyreCompound == "Inters" || visualTyreCompound == "Wet") {
                        return visualTyreCompound;
                    } else {
                        return actualTyreCompound + " - " + visualTyreCompound;
                    }
                }

                const tyreInfoCell = row.insertCell();
                const currTyreWearData = tyreInfoData["current-wear"];
                let tyreWearText = "";
                if (tyreWearAverageFormat) {
                    if (currTyreWearData) {
                        tyreWearText = formatFloatWithTwoDecimals(currTyreWearData["average"]) + "%";
                    } else {
                        tyreWearText = "N/A";
                    }
                } else {
                    if (currTyreWearData) {
                        maxTyreWearData = getMaxTyreWear(currTyreWearData);
                        tyreWearText = `${maxTyreWearData["max-key"]}: ${formatFloatWithTwoDecimals(maxTyreWearData["max-wear"])}%`
                    } else {
                        tyreWearText = "N/A";
                    }
                }

                const tyreCompound = getTyreCompoundStr(tyreInfoData["visual-tyre-compound"], tyreInfoData["actual-tyre-compound"]);
                tyreInfoCell.innerHTML = `${tyreWearText}<br>` +
                    `${tyreInfoData["tyre-age"]} lap(s) ` + `(${tyreInfoData["num-pitstops"]} pit)<br>` +
                    `${tyreCompound}`;
            }

            function addTyrePredictionInfo(row, predictionData) {

                if (!shouldHidePredictionColumn) {
                    let predictionHTML = "";
                    if (predictionData.length === 0) {
                        predictionHTML = "N/A";
                    } else {
                        predictionData.forEach((prediction, index) => {
                            const lapNum = prediction["lap-number"];
                            if (tyreWearAverageFormat) {
                                predictionHTML += "L" + lapNum + ": " + formatFloatWithTwoDecimals(prediction["average"]) + "%<br>";
                            } else {
                                const maxWearInfo = getMaxTyreWear(prediction);
                                const maxWear = formatFloatWithTwoDecimals(maxWearInfo["max-wear"]);
                                const maxKey = maxWearInfo["max-key"];
                                predictionHTML += "L" + lapNum + ": " + maxKey + " - " + maxWear + "%<br>";
                            }
                        });
                    }
                    row.insertCell().innerHTML = predictionHTML;
                }
            }

            function addDamageInfo(row, damageInfo) {

                // Wing damage key will always be present
                let flWingDamage = damageInfo["fl-wing-damage"] == null ? "N/A" :
                    formatFloatWithTwoDecimals(damageInfo["fl-wing-damage"]) + "%";
                let frWingDamage = damageInfo["fr-wing-damage"] == null ? "N/A" :
                    formatFloatWithTwoDecimals(damageInfo["fr-wing-damage"]) + "%";
                let rearWingDamage = damageInfo["rear-wing-damage"] == null ? "N/A" :
                    formatFloatWithTwoDecimals(damageInfo["rear-wing-damage"]) + "%";
                row.insertCell().innerHTML = `
                    FL: ${flWingDamage}<br>
                    FR: ${frWingDamage}<br>
                    RW: ${rearWingDamage}
                `;
            }

            function addFuelInfo(row, fuelInfo) {

                if (!shouldHideFuelColumn) {
                    // Fuel info
                    const currFuelRate = fuelInfo["curr-fuel-rate"] !== null
                        ? formatFloatWithTwoDecimals(fuelInfo["curr-fuel-rate"])
                        : "N/A";
                    const targetFuelRate = fuelInfo["target-fuel-rate"] !== null
                        ? formatFloatWithTwoDecimals(fuelInfo["target-fuel-rate"])
                        : "N/A";
                    const lastLapFuelUsed = fuelInfo["last-lap-fuel-used"] !== null
                        ? formatFloatWithTwoDecimals(fuelInfo["last-lap-fuel-used"])
                        : "N/A";

                    row.insertCell().innerHTML = `
                        Last: ${lastLapFuelUsed}<br>
                        Curr: ${currFuelRate}<br>
                        Tgt: ${targetFuelRate}<br>
                    `;
                }
            }

            function formatRow(row, entry, nameLink) {

                // Add the required styles
                row.className = '';
                if (entry["driver-info"]["is-fastest"]) {
                    row.classList.add('fastest-lap');
                }

                switch (entry["dnf-status"]) {
                    case "DNF":
                        row.classList.add('dnf');
                        break;
                    case "DSQ":
                        row.classList.add('dsq');
                        break;
                    // Add more cases if needed
                    default:
                    // Default case if none of the cases match
                }

                if (entry["driver-info"]["is-player"]) {
                    row.classList.add('player-row'); // Apply the player-row class to the row
                }

                // Fix for DRS active styling
                if (entry["driver-info"]["drs"] === true) {
                    Array.from(row.cells).forEach(cell => cell.classList.add('drs-active'));
                    row.classList.add('drs-active'); // Add class to the row
                    nameLink.classList.add('drs-active')
                }
            }

            const tableBody = document.querySelector('#raceTable tbody');
            tableBody.innerHTML = '';

            entries.forEach(entry => {

                // Create a row for this entry
                const row = tableBody.insertRow();
                const isPlayer = entry["driver-info"]["is-player"];
                const isSpectating = entry["driver-info"]["is-spectating"];

                // Populate the row
                addPositionInfo(row, entry["driver-info"]);
                let nameLink = addNameInfo(row, entry["driver-info"]);
                addDeltaInfo(row, entry["delta-info"]);
                addErsInfo(row, entry["ers-info"]);
                addWarningsPensInfo(row, entry["warns-pens-info"]);
                addBestLapInfo(row, entry["lap-info"], isPlayer, isSpectating);
                addLastLapInfo(row, entry["lap-info"], isPlayer);
                addCurrTyreInfo(row, entry["tyre-info"]);
                addTyrePredictionInfo(row, entry["tyre-info"]["wear-prediction"]);
                addDamageInfo(row, entry["damage-info"]);
                addFuelInfo(row, entry["fuel-info"]);

                // Add the styles
                formatRow(row, entry, nameLink);
            });
        }

        function handleDriverInfoClick(index) {

            if ({{ live_data_mode | tojson | safe }}) {
                socket.emit('driver-info', {index: index});
            } else {
                fetch(`/driver-info?index=${index}`)
                    .then(response => response.json())
                    .then(data => {
                        openDriverInfoModal(data);
                    })
                    .catch(error => {
                        console.error('Error fetching driver info:', error);
                    });
            }
        }

        function createAccordion(title, content) {
            const accordion = document.createElement('div');
            accordion.className = 'accordion';

            const accordionTitle = document.createElement('button');
            accordionTitle.className = 'accordion-title';
            accordionTitle.innerText = title;

            const accordionContent = document.createElement('div');
            accordionContent.className = 'accordion-content';
            accordionContent.appendChild(content);

            accordion.appendChild(accordionTitle);
            accordion.appendChild(accordionContent);

            // Add event listener for the accordion
            accordionTitle.addEventListener('click', function () {
                accordion.classList.toggle('active');
                if (accordion.classList.contains('active')) {
                    // Set max-height to the scrollHeight only if the accordion is being opened
                    accordionContent.style.maxHeight = accordionContent.scrollHeight + 'px';
                } else {
                    // Set max-height to 0 when the accordion is being closed
                    accordionContent.style.maxHeight = null;
                }
            });

            return accordion;
        }

        function getDriverInfoFromIndex(data, index) {
            const classificationData = data["classification-data"];

            for (let i = 0; i < classificationData.length; i++) {
                const driverData = classificationData[i];

                if (driverData["index"] == index) {
                    return {
                        'driver-name': driverData["participant-data"]["name"],
                        'team-name': getTeamName(driverData["participant-data"]["team-id"])
                    };
                }
            }

            // If the index is not found, return null values
            return {
                'driver-name': null,
                'team-name': null
            };
        }

        function openRaceInfoModal(data) {

            const modalContent = document.getElementById('modalContent');
            modalContent.innerHTML = '';

            function getFastestTimesRecordsContent(data) {

                function insertFastestRow(data, timesRecordsTableBody, category, searchKey) {

                    const fastestLapTime = data["records"]["fastest"][searchKey]["time-str"];
                    const fastestDriverIndex = data["records"]["fastest"][searchKey]["driver-index"];
                    const fastestLapNum = data["records"]["fastest"][searchKey]["lap-number"];
                    const driverIndex = data["records"]["fastest"][searchKey]["driver-index"];
                    const driverName = data["records"]["fastest"][searchKey]["driver-name"];
                    const teamName = getTeamName(data["records"]["fastest"][searchKey]["team-id"]);
                    const row = timesRecordsTableBody.insertRow();
                    row.innerHTML = `
                        <td>${category}</td>
                        <td>${driverName}</td>
                        <td>${teamName}</td>
                        <td>${fastestLapNum}</td>
                        <td>${fastestLapTime}</td>
                    `;
                }

                function isFastestRecordAvailable(data) {

                    if ("records" in data &&
                        'fastest' in data["records"] &&
                        data["records"]["fastest"]["lap"] != null &&
                        data["records"]["fastest"]["s1"] != null &&
                        data["records"]["fastest"]["s2"] != null &&
                        data["records"]["fastest"]["s3"] != null) {
                        return true;
                    }
                    return false;
                }

                const timesRecordsContent = document.createElement('div');
                const timesRecordsSubDiv = document.createElement('div');
                const timesRecordsTable = document.createElement('table');
                timesRecordsSubDiv.appendChild(timesRecordsTable);
                timesRecordsTable.classList.add('times-records-table');

                const timesRecordsHeader = timesRecordsTable.createTHead();
                const headerRow = timesRecordsHeader.insertRow();
                headerRow.innerHTML = `
                    <th>Category</th>
                    <th>Driver</th>
                    <th>Team</th>
                    <th>Lap</th>
                    <th>Time</th>
                `;

                const timesRecordsTableBody = timesRecordsTable.createTBody();
                if (isFastestRecordAvailable(data)) {
                    if ('lap' in data["records"]["fastest"]) {
                        insertFastestRow(data, timesRecordsTableBody, "Lap", "lap");
                    }
                    if ('s1' in data["records"]["fastest"]) {
                        insertFastestRow(data, timesRecordsTableBody, "Sector 1", "s1");
                    }
                    if ('s2' in data["records"]["fastest"]) {
                        insertFastestRow(data, timesRecordsTableBody, "Sector 2", "s2");
                    }
                    if ('s3' in data["records"]["fastest"]) {
                        insertFastestRow(data, timesRecordsTableBody, "Sector 3", "s3");
                    }
                } else {
                    const row = timesRecordsTableBody.insertRow();
                    row.innerHTML = '<td colspan="5">Fastest Times Records data not available</td>';
                }
                timesRecordsContent.appendChild(createAccordion('Fastest Times Records', timesRecordsSubDiv));
                return timesRecordsContent;
            }

            function getTyreStintRecordsContent(data) {

                function insertTyreStintRecordRow(data, timesRecordsTableBody, compound, compoundRecords) {

                    const longestTyreStintDriverName = compoundRecords["longest-tyre-stint"]["driver-name"];
                    const longestTyreStintLength = compoundRecords["longest-tyre-stint"]["value"];

                    const lowestTyreWearPerLapDriverName = compoundRecords["lowest-tyre-wear-per-lap"]["driver-name"];
                    const lowestTyreWearPerLap = compoundRecords["lowest-tyre-wear-per-lap"]["value"];

                    const highestTyreWearDriverName = compoundRecords["highest-tyre-wear"]["driver-name"];
                    const highestTyreWear = compoundRecords["highest-tyre-wear"]["value"];

                    const row1 = timesRecordsTableBody.insertRow();
                    const compoundCell1 = row1.insertCell();
                    compoundCell1.textContent = compound;
                    compoundCell1.setAttribute('rowspan', '3'); // Merge cells vertically

                    row1.insertCell().textContent = 'Longest Stint';
                    row1.insertCell().textContent = longestTyreStintDriverName;
                    row1.insertCell().textContent = longestTyreStintLength + " laps";

                    const row2 = timesRecordsTableBody.insertRow();
                    row2.insertCell().textContent = 'Least Tyre Wear Per Lap';
                    row2.insertCell().textContent = lowestTyreWearPerLapDriverName;
                    row2.insertCell().textContent = formatFloatWithTwoDecimals(lowestTyreWearPerLap) + "%";

                    const row3 = timesRecordsTableBody.insertRow();
                    row3.insertCell().textContent = 'Highest Tyre Wear';
                    row3.insertCell().textContent = highestTyreWearDriverName;
                    row3.insertCell().textContent = highestTyreWear + "%";
                }

                function isObjectEmpty(obj) {
                    return obj && Object.keys(obj).length === 0 && obj.constructor === Object;
                }

                const tyreStintRecordsContent = document.createElement('div');
                const tyreStintRecordsSubDiv = document.createElement('div');
                const tyreStintsRecordsTable = document.createElement('table');
                tyreStintRecordsSubDiv.appendChild(tyreStintsRecordsTable);
                tyreStintsRecordsTable.classList.add('tyre-stints-records-table');

                const tyreStintsRecordsHeader = tyreStintsRecordsTable.createTHead();
                const headerRow = tyreStintsRecordsHeader.insertRow();
                headerRow.innerHTML = `
                    <th>Compound</th>
                    <th>Category</th>
                    <th>Driver</th>
                    <th>Record</th>
                `;

                const tyreStintRecordsTableBody = tyreStintsRecordsTable.createTBody();
                if ("records" in data && 'tyre-stats' in data["records"] && data["records"]["tyre-stats"] != null &&
                    !isObjectEmpty(data["records"]["tyre-stats"])) {

                    const tyreStats = data["records"]["tyre-stats"];
                    for (let compound in tyreStats) {
                        const compoundRecords = tyreStats[compound];
                        insertTyreStintRecordRow(data, tyreStintRecordsTableBody, compound, compoundRecords);
                    }

                } else {
                    const row = tyreStintRecordsTableBody.insertRow();
                    row.innerHTML = '<td colspan="4">Tyre Stint Records data not available</td>';
                }
                tyreStintRecordsContent.appendChild(createAccordion('Tyre Stint Records', tyreStintRecordsSubDiv));
                return tyreStintRecordsContent;
            }

            function getCustomMarkersContent(data) {

                const customMarkersContent = document.createElement('div');
                const customMarkersSubDiv = document.createElement('div');
                const customMarkersTable = document.createElement('table');
                customMarkersSubDiv.appendChild(customMarkersTable);
                customMarkersTable.classList.add('custom-markers-table');

                const customMarkersHeader = customMarkersTable.createTHead();
                const headerRow = customMarkersHeader.insertRow();
                headerRow.innerHTML = `
                    <th>Index</th>
                    <th>Event</th>
                    <th>Track</th>
                    <th>Sector</th>
                    <th>Lap Number</th>
                    <th>Curr Lap Time</th>
                    <th>Lap Percentage</th>
                `;

                const customMarkersTableBody = customMarkersTable.createTBody();
                if ("custom-markers" in data && data["custom-markers"].length > 0) {

                    data["custom-markers"].forEach(function (marker, index) {
                        const row = customMarkersTableBody.insertRow();
                        row.innerHTML = `
                            <td>${index + 1}</td>
                            <td>${marker["event-type"]}</td>
                            <td>${marker["track"]}</td>
                            <td>${marker["sector"]}</td>
                            <td>${marker["lap"]}</td>
                            <td>${marker["curr-lap-time"]}</td>
                            <td>${marker["curr-lap-percentage"]}</td>
                        `;
                    });

                } else {
                    const row = customMarkersTableBody.insertRow();
                    row.innerHTML = '<td colspan="7">Custom Markers data not available</td>';
                }
                customMarkersContent.appendChild(createAccordion('Custom Markers', customMarkersSubDiv));
                return customMarkersContent;
            }

            function getPositionHistoryGraph(data) {

                function getF1TeamColor(teamName) {
                    //source: https://www.reddit.com/r/formula1/comments/1avhmjb/f1_2024_hex_codes/
                    const teamColors = {
                        'Red Bull Racing': 'rgba(54,113,198, 1)',    // Blue
                        'VCARB': 'rgba(102,146,255, 1)',    // Blue
                        'Mercedes': 'rgba(39,244,210, 1)',          // Teal
                        'Ferrari': 'rgba(232,0,45, 1)',             // Red
                        'Mclaren': 'rgba(255,128,0, 1)',           // Papaya Orange
                        'Aston Martin': 'rgba(34,153,113, 1)',       // Green
                        'Alpine': 'rgba(255,135,188, 1)',            // Blue
                        'AlphaTauri': 'rgba(30, 40, 80, 1)',         // Dark Blue
                        'Alfa Romeo': 'rgba(155, 0, 0, 1)',          // Dark Red
                        'Haas': 'rgba(182,186,189, 1)',            // White/Silver
                        'Williams': 'rgba(100,196,255, 1)',          // Blue
                        'Sauber': 'rgba(82,226,82,1)'
                    };
                    return teamColors[teamName] || null;
                }

                function plotGraphPositionHistory(canvas, datasets, xAxisLabel, yAxisLabel) {
                    var xData = datasets[0].data.map(entry => entry.x);
                    var ctx = canvas.getContext('2d');
                    console.log(datasets);

                    // Define default colors to cycle through if no custom color is provided
                    const defaultColors = [
                        'rgba(75, 192, 192, 1)',   // Teal
                        'rgba(255, 99, 132, 1)',   // Red
                        'rgba(54, 162, 235, 1)',   // Blue
                        'rgba(255, 206, 86, 1)',   // Yellow
                        'rgba(153, 102, 255, 1)',  // Purple
                        'rgba(255, 159, 64, 1)',   // Orange
                        'rgba(199, 199, 199, 1)',  // Gray
                        'rgba(255, 99, 71, 1)',    // Tomato
                        'rgba(60, 179, 113, 1)',   // Medium Sea Green
                        'rgba(123, 104, 238, 1)',  // Medium Slate Blue
                        'rgba(0, 128, 128, 1)',    // Teal
                        'rgba(240, 128, 128, 1)',  // Light Coral
                        'rgba(75, 0, 130, 1)',     // Indigo
                        'rgba(250, 128, 114, 1)',  // Salmon
                        'rgba(34, 139, 34, 1)',    // Forest Green
                        'rgba(255, 215, 0, 1)',    // Gold
                        'rgba(0, 191, 255, 1)',    // Deep Sky Blue
                        'rgba(219, 112, 147, 1)',  // Pale Violet Red
                        'rgba(46, 139, 87, 1)',    // Sea Green
                        'rgba(139, 69, 19, 1)',    // Saddle Brown
                        'rgba(255, 140, 0, 1)',    // Dark Orange
                        'rgba(72, 61, 139, 1)'     // Dark Slate Blue
                    ];


                    // Define a custom plugin for labeling at the end of the line
                    const endLabelPlugin = {
                        id: 'endLabelPlugin',
                        afterDatasetsDraw(chart, args, plugins) {
                            const { ctx, data, chartArea: { right } } = chart;
                            ctx.save();

                            data.datasets.forEach((dataset, index) => {
                                const meta = chart.getDatasetMeta(index);
                                const maxLength = meta.data.length;

                                // Use the custom line color for the label text or default color
                                ctx.fillStyle = dataset.borderColor || defaultColors[index % defaultColors.length];

                                ctx.font = 'bold 16px sans-serif';
                                ctx.fillText(dataset.label, right + 10, meta.data[maxLength - 1].y);
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                            });

                            ctx.restore();
                        }
                    };

                    // Create the chart with the plugin included
                    var myChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: xData,
                            datasets: datasets.map((dataset, index) => ({
                                ...dataset,
                                data: dataset.data.map(entry => entry.y), // Use numerical values for chart
                                label: dataset.label, // Update label
                                borderColor: dataset.borderColor || defaultColors[index % defaultColors.length], // Select custom or default color
                                backgroundColor: dataset.backgroundColor || defaultColors[index % defaultColors.length].replace('1)', '0.2)'), // Default transparent background color
                                borderWidth: 2, // Default line width
                            }))
                        },
                        options: {
                            scales: {
                                x: {
                                    type: 'linear',
                                    title: {
                                        display: true,
                                        text: xAxisLabel,
                                        color: 'rgba(255, 255, 255, 0.8)',
                                        font: {
                                            size: 16
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    },
                                    ticks: {
                                        color: 'rgba(255, 255, 255, 0.8)',
                                        stepSize: 1,
                                        precision: 0
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: yAxisLabel,
                                        color: 'rgba(255, 255, 255, 0.8)',
                                        font: {
                                            size: 16
                                        }
                                    },
                                    beginAtZero: false,
                                    min: 1,
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    },
                                    ticks: {
                                        color: 'rgba(255, 255, 255, 0.8)',
                                        stepSize: 5,
                                        callback: function(value) {
                                            return value % 5 === 0 ? value : null;
                                        }
                                    },
                                    reverse: true
                                }
                            },
                            hover: {
                                mode: 'dataset',
                                intersect: false
                            },
                            onHover: function(event, activeElements) {
                                const chartArea = myChart.chartArea;
                                const mouseX = event.native.clientX;
                                const mouseY = event.native.clientY;

                                // Check if the mouse is outside the chart area
                                if (mouseX < chartArea.left || mouseX > chartArea.right || mouseY < chartArea.top || mouseY > chartArea.bottom) {
                                    // Reset all lines when mouse leaves the chart area
                                    myChart.data.datasets.forEach((dataset) => {
                                        dataset.borderWidth = 2; // Reset to default width
                                        dataset.borderColor = dataset.borderColor.replace('0.3)', '1)'); // Reset to full opacity
                                        dataset.shadowBlur = 0; // Remove shadow
                                    });
                                    myChart.update(); // Update the chart
                                    return; // Exit early if outside chart
                                }

                                const activeDatasetIndex = activeElements.length ? activeElements[0].datasetIndex : null;

                                myChart.data.datasets.forEach((dataset, index) => {
                                    if (index === activeDatasetIndex) {
                                        // Highlight hovered line
                                        dataset.borderWidth = 6;
                                        dataset.borderColor = dataset.borderColor.replace('0.3)', '1)');
                                        dataset.shadowBlur = 10;
                                        dataset.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                    } else {
                                        // Dim non-hovered lines
                                        dataset.borderWidth = 2;
                                        dataset.borderColor = dataset.borderColor.replace('1)', '0.3)');
                                        dataset.shadowBlur = 0;
                                    }
                                });

                                myChart.update(); // Update chart with new styles
                            },
                            plugins: {
                                legend: {
                                    display: false // Disable the legend
                                }
                            },
                            layout: {
                                padding: {
                                    top: 50,
                                    right: 50,
                                    bottom: 10,
                                    left: 10
                                }
                            },
                            responsive: true
                        },
                        plugins: [endLabelPlugin] // Register the end label plugin
                    });
                }

                const positionHistoryGraphContent = document.createElement('div');
                const positionHistoryGraphSubDiv = document.createElement('div');

                if ("position-history" in data && data["position-history"].length > 0) {

                    const positionHistoryArray = data["position-history"];
                    const leaderPositionHistory = positionHistoryArray[0];
                    const totalLaps = leaderPositionHistory["driver-position-history"][leaderPositionHistory["driver-position-history"].length - 1]["lap-number"];

                    let lapList = [];
                    for (let i = 0; i <= totalLaps; i++) {
                        lapList.push(i);
                    }

                    let datasets = [];
                    positionHistoryArray.forEach((driverInfo) => {
                        function getFirstThreeLetters(name) {
                            if (name.length < 3) {
                                return name.toUpperCase();
                            }
                            return name.substring(0, 3).toUpperCase();
                        }
                        const name = driverInfo["name"];
                        const team = getTeamName(driverInfo["team"]);
                        const driverPositionHistory = driverInfo["driver-position-history"];
                        let positionHistoryArray = [];
                        driverPositionHistory.forEach((perLapRecord) => {
                            positionHistoryArray.push({ x: perLapRecord["lap-number"], y: perLapRecord["position"]});
                        });
                        datasets.push({
                            label: getFirstThreeLetters(name),
                            data: positionHistoryArray,
                            borderColor: getF1TeamColor(team)
                        });
                        if (datasets[datasets.length-1].borderColor === null ) {
                            console.log("Could not find colour", driverInfo);
                        }
                    });


                    if (datasets.length > 0) {
                        // Create graph canvas
                        const graphDiv = document.createElement('div');
                        const elementId = 'positionHistoryGraph';
                        const graphCanvas = document.createElement('canvas');
                        graphDiv.appendChild(graphCanvas);
                        graphCanvas.id = elementId;
                        graphDiv.classList.add('graph-canvas');

                        // Plot graph
                        plotGraphPositionHistory(graphCanvas, datasets, 'Lap number', 'Position');
                        positionHistoryGraphSubDiv.appendChild(graphDiv);
                    }
                }

                positionHistoryGraphContent.appendChild(createAccordion('Position History', positionHistoryGraphSubDiv));
                return positionHistoryGraphContent;
            }

            // Fastest Times Records Table
            modalContent.appendChild(getFastestTimesRecordsContent(data));

            // Tyre Stints Records Table
            modalContent.appendChild(getTyreStintRecordsContent(data));

            // Custom Markers Table
            modalContent.appendChild(getCustomMarkersContent(data));

            // Position History Graph
            modalContent.appendChild(getPositionHistoryGraph(data));

            // Finalise the data
            const modalTitle = document.getElementById('modalTitle');
            modalTitle.innerText = `Race Information`;

            const modal = document.getElementById('driverInfoModal');
            modal.style.display = 'block';
        }

        function openDriverInfoModal(data) {

            // Function to plot the graph with dark theme, truncated Y-axis values, and 30% excess
            function plotGraph(canvas, datasets, xAxisLabel, yAxisLabel, formatAsLapTime = false, limits = null) {
                // Convert data to lap time format if specified
                const excessPerc = 0.2;
                if (formatAsLapTime) {
                    datasets.forEach(dataset => {
                        dataset.data.forEach(entry => {
                            entry.lapTimeString = formatLapTime(entry.y); // Store lap time string for display
                        });
                    });
                }

                var xData = datasets[0].data.map(entry => entry.x);

                let yMinWithExcess, yMaxWithExcess;
                // Calculate the range of the data
                var yMin = Math.min(...datasets.reduce((acc, dataset) => acc.concat(dataset.data.map(entry => entry.y)), []));
                var yMax = Math.max(...datasets.reduce((acc, dataset) => acc.concat(dataset.data.map(entry => entry.y)), []));

                // Calculate the 30% excess
                var excess = (yMax - yMin) * excessPerc;

                // Adjust the minimum and maximum values for the Y-axis scale with excess
                if (limits !== null) {
                    if (!("min" in limits) || limits["min"] === null) {
                        yMinWithExcess = yMin - excess;
                    } else {
                        yMinWithExcess = limits["min"];
                    }

                    if (!("max" in limits) || limits["max"] === null) {
                        yMaxWithExcess = yMax + excess;
                    } else {
                        yMaxWithExcess = limits["max"];
                    }
                }

                var ctx = canvas.getContext('2d');
                var myChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: xData,
                        datasets: datasets.map(dataset => ({
                            ...dataset,
                            data: dataset.data.map(entry => entry.y), // Use numerical values for chart
                            label: formatAsLapTime ? dataset.label + " (Lap Time)" : dataset.label // Update label if formatting as lap time
                        }))
                    },
                    options: {
                        scales: {
                            x: {
                                type: 'linear',
                                scaleLabel: {
                                    display: true,
                                    labelString: xAxisLabel,
                                    fontColor: 'rgba(255, 255, 255, 0.8)'
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                },
                                ticks: {
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    stepSize: 1, // Ensure each lap number is displayed
                                    precision: 0 // Round to whole numbers
                                }
                            },
                            y: {
                                scaleLabel: {
                                    display: true,
                                    labelString: yAxisLabel,
                                    fontColor: 'rgba(255, 255, 255, 0.8)'
                                },
                                beginAtZero: false,
                                min: yMinWithExcess,
                                max: yMaxWithExcess,
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                },
                                ticks: {
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function (value, index, values) {
                                        // Format tick values as lap time if formatting as lap time is enabled
                                        return formatAsLapTime ? formatLapTime(value) : value;
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: 'rgba(255, 255, 255, 0.8)'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        var label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += formatAsLapTime ? formatLapTime(context.parsed.y) : context.parsed.y;
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        layout: {
                            padding: {
                                top: 10,
                                right: 10,
                                bottom: 10,
                                left: 10
                            }
                        },
                        responsive: true
                    }
                });
            }

            function getCarDamageContent(data) {

                const carDamageContent = document.createElement('div');
                const carDamageTable = document.createElement('table');
                carDamageTable.classList.add('car-damage-table');
                const carDamageHeader = carDamageTable.createTHead();
                const carDamageHeaderRow = carDamageHeader.insertRow();
                carDamageHeaderRow.innerHTML = `
                    <th>Component</th>
                    <th>Damage</th>
                `;
                const carDamageBody = carDamageTable.createTBody();
                if ("car-damage" in data && data["car-damage"] != null) {
                    // Front Left Wing Damage
                    const row1 = carDamageBody.insertRow();
                    row1.innerHTML = `
                        <td>Front Left Wing Damage</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["front-left-wing-damage"])}%</td>
                    `;

                    // Front Right Wing Damage
                    const row2 = carDamageBody.insertRow();
                    row2.innerHTML = `
                        <td>Front Right Wing Damage</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["front-right-wing-damage"])}%</td>
                    `;

                    // Rear Wing Damage
                    const row3 = carDamageBody.insertRow();
                    row3.innerHTML = `
                        <td>Rear Wing Damage</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["rear-wing-damage"])}%</td>
                    `;
                } else {
                    const row = carDamageBody.insertRow();
                    row.innerHTML = '<td colspan="2">Car Damage data not available</td>';
                }
                carDamageContent.appendChild(createAccordion('Car Damage', carDamageTable));
                return carDamageContent;
            }

            function getTyreDamageContent(data) {

                const tyreDamageContent = document.createElement('div');
                const tyreDamageTable = document.createElement('table');
                tyreDamageTable.classList.add('tyre-damage-table');
                const tyreDamageHeader = tyreDamageTable.createTHead();
                const tyreDamageHeaderRow = tyreDamageHeader.insertRow();
                tyreDamageHeaderRow.innerHTML = `
                    <th>Tyre</th>
                    <th>Damage</th>
                `;
                const tyreDamageBody = tyreDamageTable.createTBody();
                if ("car-damage" in data && data["car-damage"] != null) {
                    // Front Left Tyre Damage
                    const row1 = tyreDamageBody.insertRow();
                    row1.innerHTML = `
                        <td>Front Left Tyre Damage</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["tyres-damage"][2])}%</td>
                    `;

                    // Front Right Tyre Damage
                    const row2 = tyreDamageBody.insertRow();
                    row2.innerHTML = `
                        <td>Front Right Tyre Damage</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["tyres-damage"][3])}%</td>
                    `;

                    // Rear Left Tyre Damage
                    const row3 = tyreDamageBody.insertRow();
                    row3.innerHTML = `
                        <td>Rear Left Tyre Damage</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["tyres-damage"][0])}%</td>
                    `;

                    // Rear Right Tyre Damage
                    const row4 = tyreDamageBody.insertRow();
                    row4.innerHTML = `
                        <td>Rear Right Tyre Damage</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["tyres-damage"][1])}%</td>
                    `;
                } else {
                    const row = tyreDamageBody.insertRow();
                    row.innerHTML = '<td colspan="2">Tyre Damage data not available</td>';
                }
                tyreDamageContent.appendChild(createAccordion('Tyre Damage', tyreDamageTable));
                return tyreDamageContent;
            }

            function getCollisionsContent(data) {

                function getOtherDriverName(index, data) {

                    if (index == data["driver-1-index"]) {
                        return data["driver-2-name"];
                    } else {
                        return data["driver-1-name"];
                    }
                }

                const collisionsContent = document.createElement('div');
                const collisionsTable = document.createElement('table');
                collisionsTable.classList.add('collisions-table');
                const collisionsHeader = collisionsTable.createTHead();
                const collisionsBody = collisionsTable.createTBody();
                if ("collisions" in data) {
                    const playerIndex = data["index"];
                    // Collision count
                    const row1 = collisionsBody.insertRow();
                    const collisionsCount = data["collisions"]["records"].length;
                    row1.innerHTML = `
                        <td>Total count</td>
                        <td>${collisionsCount}</td>
                    `;

                    const count = data["collisions"]["most-collided-pairs"]["count"];
                    const collisionPairs = data["collisions"]["most-collided-pairs"]["collision-pairs"];
                    collisionPairs.forEach((pair) => {
                        const otherDriverName = getOtherDriverName(playerIndex, pair);
                        const row = collisionsBody.insertRow();
                        row.innerHTML = `
                            <td>Collisions with ${otherDriverName}</td>
                            <td>${count}</td>
                        `;
                    });

                } else {
                    const row = collisionsBody.insertRow();
                    row.innerHTML = '<td colspan="2">Collisions data not available</td>';
                }
                collisionsContent.appendChild(createAccordion('Collisions', collisionsTable));
                return collisionsContent;
            }

            function getTyreWearContent(data) {

                const tyreWearContent = document.createElement('div');
                const tyreWearTable = document.createElement('table');
                tyreWearTable.classList.add('tyre-damage-table');
                const tyreWearHeader = tyreWearTable.createTHead();
                const tyreWearHeaderRow = tyreWearHeader.insertRow();
                tyreWearHeaderRow.innerHTML = `
                    <th>Tyre</th>
                    <th>Wear</th>
                `;
                const tyreWearBody = tyreWearTable.createTBody();
                if ("car-damage" in data && data["car-damage"] != null) {
                    // Front Left Tyre Wear
                    const row1 = tyreWearBody.insertRow();
                    row1.innerHTML = `
                        <td>Front Left Tyre Wear</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["tyres-wear"][2])}%</td>
                    `;

                    // Front Right Tyre Wear
                    const row2 = tyreWearBody.insertRow();
                    row2.innerHTML = `
                        <td>Front Right Tyre Wear</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["tyres-wear"][3])}%</td>
                    `;

                    // Rear Left Tyre Wear
                    const row3 = tyreWearBody.insertRow();
                    row3.innerHTML = `
                        <td>Rear Left Tyre Wear</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["tyres-wear"][0])}%</td>
                    `;

                    // Rear Right Tyre Wear
                    const row4 = tyreWearBody.insertRow();
                    row4.innerHTML = `
                        <td>Rear Right Tyre Wear</td>
                        <td>${formatFloatWithTwoDecimals(data["car-damage"]["tyres-wear"][1])}%</td>
                    `;
                } else {
                    const row = tyreWearBody.insertRow();
                    row.innerHTML = '<td colspan="2">Tyre Wear data not available</td>';
                }
                tyreWearContent.appendChild(createAccordion('Tyre Wear', tyreWearTable));
                return tyreWearContent;
            }

            function getCarSetupContent(data) {

                function kebabToTitleCase(str) {
                    return str
                        .split('-')          // Split the string by the hyphen
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1)) // Capitalize the first letter of each word
                        .join(' ');          // Join the words with a space
                }

                const carSetupContent = document.createElement('div');
                const carSetupTable = document.createElement('table');
                carSetupTable.classList.add('car-setup-table');
                const carSetupBody = carSetupTable.createTBody();

                if ("car-setup" in data && data["car-setup"] != null) {
                    if (!data["car-setup"]["is-valid"]) {
                        const row = carSetupBody.insertRow();
                        row.innerHTML = '<td colspan="2">Car setup data not available</td>';
                    } else {
                        for (const key in data["car-setup"]) {
                            if (key !== 'is-valid') {
                                const value = data["car-setup"][key];
                                const row = carSetupBody.insertRow();
                                row.innerHTML = `
                                    <td>${kebabToTitleCase(key)}</td>
                                    <td>${value}</td>
                                `;
                            }
                        }
                    }
                } else {
                    const row = carSetupBody.insertRow();
                    row.innerHTML = '<td colspan="2">Car setup data not available</td>';
                }
                carSetupContent.appendChild(createAccordion('Car Setup', carSetupTable));
                return carSetupContent;
            }

            function getLapHistoryContent(data) {

                const lapHistoryContent = document.createElement('div');
                const lapHistorySubDiv = document.createElement('div');
                const lapHistoryTable = document.createElement('table');
                lapHistorySubDiv.appendChild(lapHistoryTable);
                lapHistoryTable.classList.add('lap-history-table');

                const lapHistoryHeader = lapHistoryTable.createTHead();
                const headerRow = lapHistoryHeader.insertRow();
                headerRow.innerHTML = `
                    <th>Lap</th>
                    <th>S1 Time</th>
                    <th>S2 Time</th>
                    <th>S3 Time</th>
                    <th>Total Time</th>
                `;

                const lapHistoryBody = lapHistoryTable.createTBody();
                // Data arrays for plotting graph
                let graphDataS1 = [];
                let graphDataS2 = [];
                let graphDataS3 = [];
                let graphDataTotal = [];
                if ("session-history" in data && data["session-history"] != null) {
                    const lapHistoryData = data["session-history"]["lap-history-data"];
                    const bestLapNum = data["session-history"]["best-lap-time-lap-num"];
                    const bestSector1Num = data["session-history"]["best-sector-1-lap-num"];
                    const bestSector2Num = data["session-history"]["best-sector-2-lap-num"];
                    const bestSector3Num = data["session-history"]["best-sector-3-lap-num"];

                    lapHistoryData.forEach((lap, index) => {
                        const row = lapHistoryBody.insertRow();
                        const currentLapNum = index + 1;

                        if (lap["lap-time-in-ms"] == 0 &&
                            lap["sector-1-time-in-ms"] == 0 &&
                            lap["sector-2-time-in-ms"] == 0 &&
                            lap["sector-3-time-in-ms"] == 0) {
                            return;
                        }

                        row.innerHTML = `
                            <td>${currentLapNum}</td>
                            <td>${lap["sector-1-time-str"]}</td>
                            <td>${lap["sector-2-time-str"]}</td>
                            <td>${lap["sector-3-time-str"]}</td>
                            <td>${lap["lap-time-str"]}</td>
                        `;

                        // Check and mark green for best sector 1
                        const greenSectorColor = '#32F129';
                        const redSectorColor = '#f12929';
                        const fullLapValidBitMask = 1;
                        const sector1ValidBitMask = 2;
                        const sector2ValidBitMask = 4;
                        const sector3ValidBitMask = 8;

                        if (currentLapNum === bestSector1Num) {
                            row.cells[1].style.color = greenSectorColor;
                        } else if ((lap["lap-valid-bit-flags"] & sector1ValidBitMask) == 0) {
                            row.cells[1].style.color = redSectorColor;
                        }

                        // Check and mark green for best sector 2
                        if (currentLapNum === bestSector2Num) {
                            row.cells[2].style.color = greenSectorColor;
                        } else if ((lap["lap-valid-bit-flags"] & sector2ValidBitMask) == 0) {
                            row.cells[2].style.color = redSectorColor;
                        }

                        // Check and mark green for best sector 3
                        if (currentLapNum === bestSector3Num) {
                            row.cells[3].style.color = greenSectorColor;
                        } else if ((lap["lap-valid-bit-flags"] & sector3ValidBitMask) == 0) {
                            row.cells[3].style.color = redSectorColor;
                        }

                        // Check and mark green for total time
                        if (currentLapNum === bestLapNum) {
                            row.cells[4].style.color = greenSectorColor;
                        } else if ((lap["lap-valid-bit-flags"] & fullLapValidBitMask) == 0) {
                            row.cells[4].style.color = redSectorColor;
                        }

                        // Insert into the data structure for the graph
                        graphDataS1.push({ x: currentLapNum, y: lap["sector-1-time-in-ms"] });
                        graphDataS2.push({ x: currentLapNum, y: lap["sector-2-time-in-ms"] });
                        graphDataS3.push({ x: currentLapNum, y: lap["sector-3-time-in-ms"] });
                        graphDataTotal.push({ x: currentLapNum, y: lap["lap-time-in-ms"] });
                    });
                } else {
                    const row = lapHistoryBody.insertRow();
                    row.innerHTML = '<td colspan="5">Lap History data not available</td>';
                }

                if (graphDataTotal.length > 0) {
                    // Create graph canvas
                    const graphDiv = document.createElement('div');
                    const elementId = 'lapTimeGraph';
                    const graphCanvas = document.createElement('canvas');
                    graphDiv.appendChild(graphCanvas);
                    graphCanvas.id = elementId;
                    graphDiv.classList.add('graph-canvas');
                    // graphCanvas.classList.add('graph-canvas');

                    // Plot graph
                    var datasets = [
                        {
                            label: 'S1 Time',
                            data: graphDataS1
                        },
                        {
                            label: 'S2 Time',
                            data: graphDataS2
                        },
                        {
                            label: 'S3 Time',
                            data: graphDataS3
                        },
                        {
                            label: 'Lap Time',
                            data: graphDataTotal
                        }
                    ];
                    limits = {
                        min: 0
                    }
                    const formatAsLapTime = true;
                    plotGraph(graphCanvas, datasets, 'Lap number', 'Time', formatAsLapTime, limits);
                    lapHistorySubDiv.appendChild(graphDiv);
                }
                lapHistoryContent.appendChild(createAccordion('Lap History', lapHistorySubDiv));
                return lapHistoryContent;
            }

            function getErsHistoryContent(data) {

                const ersHistoryContent = document.createElement('div');
                const ersHistoryTable = document.createElement('table');
                const ersHistorySubDiv = document.createElement('div');
                ersHistoryTable.classList.add('ers-damage-table');
                ersHistorySubDiv.appendChild(ersHistoryTable);
                const ersHistoryHeader = ersHistoryTable.createTHead();
                const ersHistoryHeaderRow = ersHistoryHeader.insertRow();
                ersHistoryHeaderRow.innerHTML = `
                    <th>Lap</th>
                    <th>ERS remaining</th>
                    <th>ERS deployed</th>
                    <th>Harvested - MGU-H</th>
                    <th>Harvested - MGU-K</th>
                    <th>Harvested - Total</th>
                `;
                const ersHistoryBody = ersHistoryTable.createTBody();
                // Data arrays for plotting graph
                let graphDataDeployed = [];
                let graphDataRemaining = [];
                let graphDataHarvested = [];

                if ("per-lap-info" in data && data["per-lap-info"] != null) {
                    const perLapHistoryData = data["per-lap-info"];
                    if (perLapHistoryData.length > 0) {
                        perLapHistoryData.forEach((lap, index) => {
                            const row = ersHistoryBody.insertRow();
                            const currentLapNum = lap["lap-number"];
                            if (currentLapNum == 0) {
                                // Skip lap 0 for ERS, we want that only for fuel
                                // If this is the only lap info available, print the standard error message
                                if (perLapHistoryData.length == 1) {
                                    row.innerHTML = '<td colspan="6">ERS data not available</td>';
                                }

                                return;
                            }
                            let ersRemainingPerc = "---";
                            let ersDeployedPerc = "---";
                            let ersHarvestedMguHPerc = "---";
                            let ersHarvestedMguKPerc = "---";
                            let ersHarvestedTotalPerc = "---";

                            if ("car-status-data" in lap) {
                                const maxErsCapacity = lap["car-status-data"]["ers-max-capacity"];
                                const ersRemainingVal = lap["car-status-data"]["ers-store-energy"];
                                const ersDeployedThisLapVal = lap["car-status-data"]["ers-deployed-this-lap"];
                                const ersHarvestedThisLapMguHVal = lap["car-status-data"]["ers-harvested-this-lap-mguh"];
                                const ersHarvestedThisLapMguKVal = lap["car-status-data"]["ers-harvested-this-lap-mguk"];

                                ersRemainingPerc = formatFloatWithTwoDecimals(
                                    (ersRemainingVal / maxErsCapacity) * 100) + "%";
                                ersDeployedPerc = formatFloatWithTwoDecimals(
                                    (ersDeployedThisLapVal / maxErsCapacity) * 100) + "%";
                                ersHarvestedMguHPerc = formatFloatWithTwoDecimals(
                                    (ersHarvestedThisLapMguHVal / maxErsCapacity) * 100) + "%";
                                ersHarvestedMguKPerc = formatFloatWithTwoDecimals(
                                    (ersHarvestedThisLapMguKVal / maxErsCapacity) * 100) + "%";
                                ersHarvestedTotalPerc = formatFloatWithTwoDecimals(
                                    ((ersHarvestedThisLapMguHVal + ersHarvestedThisLapMguKVal) / maxErsCapacity)
                                    * 100) + "%";

                                graphDataDeployed.push({ x: parseFloat(currentLapNum), y: ((ersDeployedThisLapVal / maxErsCapacity) * 100) });
                                graphDataRemaining.push({ x: parseFloat(currentLapNum), y: ((ersRemainingVal / maxErsCapacity) * 100) });
                                graphDataHarvested.push({ x: parseFloat(currentLapNum), y: (((ersHarvestedThisLapMguHVal + ersHarvestedThisLapMguKVal) / maxErsCapacity) * 100) });
                            }

                            row.innerHTML = `
                                <td>${currentLapNum}</td>
                                <td>${ersRemainingPerc}</td>
                                <td>${ersDeployedPerc}</td>
                                <td>${ersHarvestedMguHPerc}</td>
                                <td>${ersHarvestedMguKPerc}</td>
                                <td>${ersHarvestedTotalPerc}</td>
                            `;
                        });
                    } else {
                        const row = ersHistoryBody.insertRow();
                        row.innerHTML = '<td colspan="6">ERS History data not available</td>';
                    }
                } else {
                    const row = ersHistoryBody.insertRow();
                    row.innerHTML = '<td colspan="6">ERS History data not available</td>';
                }

                if (graphDataDeployed.length > 0) {
                    // Create graph canvas
                    const graphDiv = document.createElement('div');
                    const elementId = 'ersGraph';
                    const graphCanvas = document.createElement('canvas');
                    graphDiv.appendChild(graphCanvas);
                    graphCanvas.id = elementId;
                    graphDiv.classList.add('graph-canvas');
                    // graphCanvas.classList.add('graph-canvas');

                    // Plot graph
                    var datasets = [
                        {
                            label: 'ERS Deployed',
                            data: graphDataDeployed
                        },
                        {
                            label: 'ERS Remaining',
                            data: graphDataRemaining
                        },
                        {
                            label: 'ERS Harvested',
                            data: graphDataHarvested
                        }
                    ];
                    var limits = {
                        min: 0,
                        max: 100
                    }
                    const formatAsLapTime = false;
                    plotGraph(graphCanvas, datasets, 'Lap number', 'ERS (%)', formatAsLapTime, limits);
                    ersHistorySubDiv.appendChild(graphDiv);
                }
                ersHistoryContent.appendChild(createAccordion('ERS History', ersHistorySubDiv));
                return ersHistoryContent;
            }

            function getFuelHistoryContent(data) {

                const fuelHistoryContent = document.createElement('div');
                const fuelHistorySubDiv = document.createElement('div');
                const fuelHistoryTable = document.createElement('table');
                fuelHistorySubDiv.appendChild(fuelHistoryTable);
                fuelHistoryTable.classList.add('fuel-damage-table');
                const fuelHistoryHeader = fuelHistoryTable.createTHead();
                const fuelHistoryHeaderRow = fuelHistoryHeader.insertRow();
                fuelHistoryHeaderRow.innerHTML = `
                    <th>Lap</th>
                    <th>Fuel Load (kg)</th>
                    <th>Usage Per Lap (kg)</th>
                    <th>Excess Laps</th>
                    <th>Excess Laps Delta</th>
                `;
                const fuelHistoryBody = fuelHistoryTable.createTBody();
                // Data array for plotting graph
                let graphData = [];

                if ("per-lap-info" in data && data["per-lap-info"] != null) {
                    const perLapHistoryData = data["per-lap-info"];
                    if (perLapHistoryData.length > 0) {
                        perLapHistoryData.forEach((lap, index) => {
                            const row = fuelHistoryBody.insertRow();
                            const currentLapNum = lap["lap-number"];

                            let fuelLoad = "---";
                            let fuelLaps = "---";
                            let usagePerLap = "---";
                            let fuelLapsDelta = "---";

                            if ("car-status-data" in lap) {
                                const fuelLoadVal = lap["car-status-data"]["fuel-in-tank"];
                                const fuelLapsVal = lap["car-status-data"]["fuel-remaining-laps"];

                                fuelLoad = formatFloatWithTwoDecimals(fuelLoadVal);
                                fuelLaps = formatFloatWithTwoDecimals(fuelLapsVal);

                                if (index > 0 && "car-status-data" in data["per-lap-info"][index - 1]) {
                                    const fuelLoadValPrev = data["per-lap-info"][index - 1]["car-status-data"]["fuel-in-tank"];
                                    const fuelLapsValPrev = data["per-lap-info"][index - 1]["car-status-data"]["fuel-remaining-laps"];

                                    usagePerLap = formatFloatWithTwoDecimals(fuelLoadValPrev - fuelLoadVal);
                                    fuelLapsDelta = formatFloatWithTwoDecimalsSigned(fuelLapsValPrev - fuelLapsVal);
                                }
                            }

                            // Push data to graphData array
                            if (currentLapNum > 0) {
                                graphData.push({ x: parseFloat(currentLapNum), y: parseFloat(usagePerLap) });
                            }

                            row.innerHTML = `
                                <td>${currentLapNum}</td>
                                <td>${fuelLoad}</td>
                                <td>${usagePerLap}</td>
                                <td>${fuelLaps}</td>
                                <td>${fuelLapsDelta}</td>
                            `;
                        });
                    } else {
                        const row = fuelHistoryBody.insertRow();
                        row.innerHTML = '<td colspan="6">ERS History data not available</td>';
                    }
                } else {
                    const row = fuelHistoryBody.insertRow();
                    row.innerHTML = '<td colspan="6">ERS History data not available</td>';
                }

                if (graphData.length > 0) {
                    // Create graph canvas

                    const graphDiv = document.createElement('div');
                    const elementId = 'fuelLoadGraph';
                    const graphCanvas = document.createElement('canvas');
                    graphDiv.appendChild(graphCanvas);
                    graphCanvas.id = elementId;
                    graphDiv.classList.add('graph-canvas');
                    // graphCanvas.classList.add('graph-canvas');

                    // Plot graph
                    var datasets = [
                        {
                            label: 'Fuel Usage Per Lap Graph',
                            data: graphData
                        }
                    ];
                    var limits = {
                        min: 0
                    }
                    const formatAsLapTime = false;
                    plotGraph(graphCanvas, datasets, 'Lap number', 'Fuel Usage (kg)', formatAsLapTime, limits);
                    fuelHistorySubDiv.appendChild(graphDiv);
                }
                fuelHistoryContent.appendChild(createAccordion('Fuel History', fuelHistorySubDiv));
                return fuelHistoryContent;
            }

            // Remove tyre sets that are not available and sort them by compound name
            function getTyreSetsInfoContent(data) {

                function sanitizeTyreSetData(tyre_set_data) {
                    const available_tyres = tyre_set_data
                        .filter(tyre => tyre.available === true)
                        .map((tyre, index) => ({ ...tyre, index }));
                    const sorted_tyres = available_tyres.sort(
                        (a, b) => a["actual-tyre-compound"].localeCompare(b["actual-tyre-compound"]));
                    return sorted_tyres;
                }

                const tyreSetsInfoContent = document.createElement('div');
                const tyreSetsInfoTable = document.createElement('table');
                tyreSetsInfoTable.classList.add('tyre-sets-info-table');
                const tyreSetsInfoTableHeader = tyreSetsInfoTable.createTHead();
                const tyreSetsInfoTableHeaderRow = tyreSetsInfoTableHeader.insertRow();
                tyreSetsInfoTableHeaderRow.innerHTML = `
                    <th>Index</th>
                    <th>Compound</th>
                    <th>Wear</th>
                    <th>Lifespan</th>
                    <th>Lap Delta</th>
                `;
                const tyreSetsInfoBody = tyreSetsInfoTable.createTBody();
                if ("tyre-sets" in data && data["tyre-sets"] != null) {

                    const tyreSetsInfoList = sanitizeTyreSetData(data["tyre-sets"]["tyre-set-data"]);
                    if (tyreSetsInfoList.length > 0) {

                        tyreSetsInfoList.forEach((tyreSet) => {
                            const row = tyreSetsInfoBody.insertRow();
                            row.innerHTML = `
                                <td>${tyreSet["index"]}</td>
                                <td>${tyreSet["actual-tyre-compound"] + " - " + tyreSet["visual-tyre-compound"]}</td>
                                <td>${tyreSet["wear"]}</td>
                                <td>${tyreSet["life-span"]} laps</td>
                                <td>${formatFloatWithTwoDecimalsSigned(tyreSet["lap-delta-time"] / 1000)}s</td>
                            `;

                            if (tyreSet["fitted"]) {
                                row.style.color = '#32F129';
                            }
                        });
                    } else {
                        const row = tyreSetsInfoBody.insertRow();
                        row.innerHTML = '<td colspan="5">Tyre Sets data not available</td>';
                    }

                } else {
                    const row = tyreSetsInfoBody.insertRow();
                    row.innerHTML = '<td colspan="5">Tyre Sets data not available</td>';
                }
                tyreSetsInfoContent.appendChild(createAccordion('Tyre Sets', tyreSetsInfoTable));
                return tyreSetsInfoContent;
            }

            function getTyreWearPredictionsContent(data) {

                const tyreWearPredictionsInfoContent = document.createElement('div');
                const tyreWearPredictionsInfoTable = document.createElement('table');
                tyreWearPredictionsInfoTable.classList.add('tyre-wear-predictions-info-table');
                const tyreWearPredictionsInfoTableHeader = tyreWearPredictionsInfoTable.createTHead();
                const tyreWearPredictionsInfoTableHeaderRow = tyreWearPredictionsInfoTableHeader.insertRow();
                tyreWearPredictionsInfoTableHeaderRow.innerHTML = `
                    <th>Lap</th>
                    <th>FL</th>
                    <th>FR</th>
                    <th>RL</th>
                    <th>RR</th>
                    <th>Average</th>
                `;
                const tyreWearPredictionsInfoBody = tyreWearPredictionsInfoTable.createTBody();
                if ("tyre-wear-predictions" in data && data["tyre-wear-predictions"] != null &&
                    "predictions" in data["tyre-wear-predictions"] &&
                        data["tyre-wear-predictions"]["predictions"] != null) {

                    const predictionsList = data["tyre-wear-predictions"]["predictions"];
                    const selectedPitStopLap = data["tyre-wear-predictions"]["selected-pit-stop-lap"];
                    if (predictionsList.length > 0) {

                        predictionsList.forEach((prediction) => {
                            const row = tyreWearPredictionsInfoBody.insertRow();
                            const fl  = prediction["front-left-wear"];
                            const fr  = prediction["front-right-wear"];
                            const rl  = prediction["rear-left-wear"];
                            const rr  = prediction["rear-right-wear"];
                            const avg = (fl + fr + rl + rr) / 4;
                            const lap = prediction["lap-number"];
                            row.innerHTML = `
                                <td>${lap}</td>
                                <td>${formatFloatWithTwoDecimals(fl)}%</td>
                                <td>${formatFloatWithTwoDecimals(fr)}%</td>
                                <td>${formatFloatWithTwoDecimals(rl)}%</td>
                                <td>${formatFloatWithTwoDecimals(rr)}%</td>
                                <td>${formatFloatWithTwoDecimals(avg)}%</td>
                            `;

                            //TODO: Add logic to highlight selected pit stop
                        });
                    } else {
                        const row = tyreWearPredictionsInfoBody.insertRow();
                        row.innerHTML = '<td colspan="6">Tyre Wear Predictions data not available</td>';
                    }

                } else {
                    const row = tyreWearPredictionsInfoBody.insertRow();
                    row.innerHTML = '<td colspan="6">Tyre Wear Predictions data not available</td>';
                }
                tyreWearPredictionsInfoContent.appendChild(createAccordion('Tyre Wear Predictions', tyreWearPredictionsInfoTable));
                return tyreWearPredictionsInfoContent;
            }

            function getTyreStintHistoryContent(data) {

                const tyreStintHistoryContent = document.createElement('div');
                const tyreStintHistorySubDiv = document.createElement('div');
                const tyreStintHistoryTable = document.createElement('table');
                tyreStintHistorySubDiv.appendChild(tyreStintHistoryTable);
                tyreStintHistoryTable.classList.add('tyre-stint-history-table');

                const tyreStintHistoryHeader = tyreStintHistoryTable.createTHead();
                const tyreStintHistoryHeaderRow = tyreStintHistoryHeader.insertRow();
                tyreStintHistoryHeaderRow.innerHTML = `
                    <th>Stint number</th>
                    <th>Start Lap</th>
                    <th>End Lap</th>
                    <th>Stint Length</th>
                    <th>Compound</th>
                    <th>Tyre Set ID</th>
                    <th>Tyre Wear</th>
                    <th>Tyre Wear Per Lap</th>
                `;

                const tyreStintHistoryBody = tyreStintHistoryTable.createTBody();
                let graphDataFL = [];
                let graphDataFR = [];
                let graphDataRL = [];
                let graphDataRR = [];
                if ("tyre-set-history" in data && data["tyre-set-history"] != null) {
                    const tyreStintHistoryData = data["tyre-set-history"];
                    tyreStintHistoryData.forEach((stintData, index) => {
                        const row = tyreStintHistoryBody.insertRow();
                        const stintId = index + 1;

                        const stintStartLap = stintData["start-lap"];
                        const stintEndLap = stintData["end-lap"];
                        const stintLength = `${stintData["stint-length"]} lap(s)`;
                        let compound = "---";
                        let tyreSetId = "---";
                        let tyreWear = "---";
                        let tyreWearPerLap = "---";

                        if ("tyre-set-data" in stintData && stintData["tyre-set-data"] != null) {
                            const tyreSetData = stintData["tyre-set-data"];
                            const tyreSetIndex = stintData["fitted-index"];

                            const actualCompound = tyreSetData["actual-tyre-compound"];
                            compound = tyreSetData["visual-tyre-compound"];
                            tyreSetId = `${actualCompound} - ${tyreSetIndex}`;
                            tyreWear = `${formatFloatWithTwoDecimals(tyreSetData["wear"])}%`;

                            // Use parseFloat to ensure numerical calculation
                            const wearPerLap = parseFloat(tyreSetData["wear"]) / parseFloat(stintData["stint-length"]);
                            tyreWearPerLap = formatFloatWithTwoDecimals(wearPerLap) + "%";
                        }

                        if ("tyre-wear-history" in stintData && stintData["tyre-wear-history"].length > 0) {

                            const wearHistory = stintData["tyre-wear-history"];
                            wearHistory.forEach(wearData => {
                                graphDataFL.push({
                                    x: wearData["lap-number"],
                                    y: formatFloatWithTwoDecimals(wearData["front-left-wear"]),
                                    desc: wearData["desc"],
                                });
                                graphDataFR.push({
                                    x: wearData["lap-number"],
                                    y: formatFloatWithTwoDecimals(wearData["front-right-wear"]),
                                    desc: wearData["desc"],
                                });
                                graphDataRL.push({
                                    x: wearData["lap-number"],
                                    y: formatFloatWithTwoDecimals(wearData["rear-left-wear"]),
                                    desc: wearData["desc"],
                                });
                                graphDataRR.push({
                                    x: wearData["lap-number"],
                                    y: formatFloatWithTwoDecimals(wearData["rear-right-wear"]),
                                    desc: wearData["desc"],
                                });
                            });
                        }

                        row.innerHTML = `
                            <td>${stintId}</td>
                            <td>${stintStartLap}</td>
                            <td>${stintEndLap}</td>
                            <td>${stintLength}</td>
                            <td>${compound}</td>
                            <td>${tyreSetId}</td>
                            <td>${tyreWear}</td>
                            <td>${tyreWearPerLap}</td>
                        `;
                    });
                } else {
                    const row = tyreStintHistoryBody.insertRow();
                    row.innerHTML = '<td colspan="8">Tyre Stint History data not available</td>';
                }

                if (graphDataFL.length > 0) {
                    // Create graph canvas

                    const graphDiv = document.createElement('div');
                    const elementId = 'tyreWearGraph';
                    const graphCanvas = document.createElement('canvas');
                    graphDiv.appendChild(graphCanvas);
                    graphCanvas.id = elementId;
                    graphDiv.classList.add('graph-canvas');

                    // Plot graph
                    var datasets = [
                        {
                            label: 'Front Left Wear',
                            data: graphDataFL
                        },
                        {
                            label: 'Front Right Wear',
                            data: graphDataFR
                        },
                        {
                            label: 'Rear Left Wear',
                            data: graphDataRL
                        },
                        {
                            label: 'Rear Right Wear',
                            data: graphDataRR
                        }
                    ];
                    var limits = {
                        min: 0,
                    }
                    const formatAsLapTime = false;
                    plotGraph(graphCanvas, datasets, 'Lap number', 'Tyre Wear %', formatAsLapTime, limits);
                    tyreStintHistorySubDiv.appendChild(graphDiv);
                    if ("is-finish-line-after-pit-garage" in data && data["is-finish-line-after-pit-garage"] === true) {
                        const tyreStintHistoryFootNote = document.createElement('p');
                        tyreStintHistoryFootNote.textContent =
                            "Cannot get fully reliable data for this circuit. Blame EA/Codemasters, not me";
                        tyreStintHistorySubDiv.appendChild(tyreStintHistoryFootNote);
                    }
                }

                tyreStintHistoryContent.appendChild(createAccordion('Tyre Stint History', tyreStintHistorySubDiv));
                return tyreStintHistoryContent;
            }

            function getWarningsAndPenaltiesContent(data) {

                const warningsPenaltiesContent = document.createElement('div');
                const warningsPenaltiesTable = document.createElement('table');
                warningsPenaltiesTable.classList.add('warnings-penalties-damage-table');
                const warningsPenaltiesHeader = warningsPenaltiesTable.createTHead();
                const warningsPenaltiesHeaderRow = warningsPenaltiesHeader.insertRow();
                warningsPenaltiesHeaderRow.innerHTML = '<th>Type</th><th>Value</th>';
                const warningsPenaltiesBody = warningsPenaltiesTable.createTBody();
                if ("lap-data" in data && data["lap-data"] != null) {
                    const lapData = data["lap-data"];
                    const numPenalties = lapData["penalties"];
                    const totalWarnings = lapData["total-warnings"];
                    const numCornerCuttingWarnings = lapData["corner-cutting-warnings"];
                    const numUnservedDriveThroughPens = lapData["num-unserved-drive-through-pens"];
                    const numUnservedStopGoPens = lapData["num-unserved-stop-go-pens"];

                    const row1 = warningsPenaltiesBody.insertRow();
                    row1.innerHTML = `
                        <td>Total penalties (time)</td>
                        <td>${numPenalties} sec</td>
                    `;

                    const row2 = warningsPenaltiesBody.insertRow();
                    row2.innerHTML = `
                        <td>Total warnings</td>
                        <td>${totalWarnings}</td>
                    `;

                    const row3 = warningsPenaltiesBody.insertRow();
                    row3.innerHTML = `
                        <td>Corner Cutting Warnings</td>
                        <td>${numCornerCuttingWarnings}</td>
                    `;

                    const row4 = warningsPenaltiesBody.insertRow();
                    row4.innerHTML = `
                        <td>Unserved Drive Through Penalties</td>
                        <td>${numUnservedDriveThroughPens}</td>
                    `;

                    const row5 = warningsPenaltiesBody.insertRow();
                    row5.innerHTML = `
                        <td>Unserved Stop Go Penalties</td>
                        <td>${numUnservedStopGoPens}</td>
                    `;

                    if (data["is-player"]) {
                        let naughtyStatus;
                        if (
                            numPenalties > 0 ||
                            totalWarnings > 0 ||
                            numCornerCuttingWarnings > 0 ||
                            numUnservedDriveThroughPens > 0 ||
                            numUnservedStopGoPens > 0
                        ) {
                            naughtyStatus = "Yes, You are naughty";
                        } else {
                            naughtyStatus = "Well, You may be naughty";
                        }
                        const row6 = warningsPenaltiesBody.insertRow();
                        row6.innerHTML = `
                            <td>Are you naughty?</td>
                            <td>${naughtyStatus}</td>
                        `;
                    }
                } else {
                    const row = warningsPenaltiesBody.insertRow();
                    row.innerHTML = '<td colspan="2">Tyre Wear data not available</td>';
                }
                warningsPenaltiesContent.appendChild(createAccordion('Warnings & Penalties', warningsPenaltiesTable));
                return warningsPenaltiesContent;
            }

            function getWarningsAndPenaltiesHistoryContent(data) {

                const warningsPenaltiesHistoryContent = document.createElement('div');
                const warningsPenaltiesHistoryTable = document.createElement('table');
                warningsPenaltiesHistoryTable.classList.add('warnings-penalties-damage-table');
                const warningsPenaltiesHistoryHeader = warningsPenaltiesHistoryTable.createTHead();
                const warningsPenaltiesHistoryHeaderRow = warningsPenaltiesHistoryHeader.insertRow();
                warningsPenaltiesHistoryHeaderRow.innerHTML = `
                    <th>Lap</th>
                    <th>Sector</th>
                    <th>Lap %</th>
                    <th>Type</th>
                    <th>Old Value</th>
                    <th>New Value</th>
                `;
                const warningsPenaltiesHistoryBody = warningsPenaltiesHistoryTable.createTBody();
                if ("warning-penalty-history" in data && data["warning-penalty-history"] != null) {
                    const warningsPenaltyHistoryList = data["warning-penalty-history"];
                    if (warningsPenaltyHistoryList.length == 0) {
                        const row = warningsPenaltiesHistoryBody.insertRow();
                        row.innerHTML = '<td colspan="6">No Warnings or Penalites</td>';
                    } else {
                        warningsPenaltyHistoryList.forEach(data => {
                            const entryType     = data["entry-type"];
                            const oldValue      = data["old-value"];
                            const newValue      = data["new-value"];
                            const lapNumber     = data["lap-number"];
                            const sectorNumber  = data["sector-number"];
                            const lapProgressPercent = data["lap-progress-percent"];

                            const row = warningsPenaltiesHistoryBody.insertRow();
                            row.innerHTML = `
                                <td>${lapNumber}</td>
                                <td>${sectorNumber}</td>
                                <td>${formatFloatWithTwoDecimals(lapProgressPercent)} %</td>
                                <td>${entryType}</td>
                                <td>${oldValue}</td>
                                <td>${newValue}</td>
                            `;
                        });
                    }
                } else {
                    const row = warningsPenaltiesHistoryBody.insertRow();
                    row.innerHTML = '<td colspan="6">No Warnings or Penalites</td>';
                }
                warningsPenaltiesHistoryContent.appendChild(createAccordion('Warnings & Penalties History', warningsPenaltiesHistoryTable));
                return warningsPenaltiesHistoryContent;
            }

            const modalContent = document.getElementById('modalContent');
            modalContent.innerHTML = '';

            const tyreWearPredictionsAvailable = "tyre-wear-predictions" in data &&
                (data["tyre-wear-predictions"]["status"] == true);

            // Car Damage Table
            modalContent.appendChild(getCarDamageContent(data));

            // Tyre Damage Table
            // modalContent.appendChild(getTyreDamageContent(data));

            // Tyre Wear Table
            modalContent.appendChild(getTyreWearContent(data));

            // Lap History Table
            modalContent.appendChild(getLapHistoryContent(data));

            // ERS history
            modalContent.appendChild(getErsHistoryContent(data));

            // Fuel history
            modalContent.appendChild(getFuelHistoryContent(data));

            // Tyre sets info
            modalContent.appendChild(getTyreSetsInfoContent(data));

            // Predictions
            modalContent.appendChild(getTyreWearPredictionsContent(data));

            // Tyre Stint History
            modalContent.appendChild(getTyreStintHistoryContent(data));

            // Warning and Penalties Table
            modalContent.appendChild(getWarningsAndPenaltiesContent(data));

            // Warning and Penalties History Table
            modalContent.appendChild(getWarningsAndPenaltiesHistoryContent(data));

            // Collisions
            modalContent.appendChild(getCollisionsContent(data));

            // Setup
            modalContent.appendChild(getCarSetupContent(data));

            // Finalise the data
            const modalTitle = document.getElementById('modalTitle');
            modalTitle.innerText = `Driver Information - ${data["driver-name"]} (${data["index"]})`;

            const modal = document.getElementById('driverInfoModal');
            modal.style.display = 'block';
        }

        function closeModal(elementId) {
            const modal = document.getElementById(elementId);
            modal.style.display = 'none';
        }

        function openSettingsModal() {
            const modalContent = document.getElementById('modalContent');
            modalContent.innerHTML = '';  // Clear previous content

            const settingsDiv = document.createElement('div');
            const settingsTable = document.createElement('table');
            settingsTable.classList.add('settings-table');
            const settingsBody = settingsTable.createTBody();

            // First row: Team Name
            let teamNameRow = settingsBody.insertRow();
            teamNameRow.innerHTML = `
                <td>My Team Name</td>
                <td><input type="text" class="team-name-input" id="teamNameInput" value="${myTeamName}"></td>
            `;

            // Radio button rows

            // Time Format
            let timeFormatRow = settingsBody.insertRow();
            timeFormatRow.innerHTML = `
                <td>Time Format</td>
                <td>
                    <label><input type="radio" name="timeFormat" value="12" ${!is24HourFormat ? 'checked' : ''}> 12 hours</label>
                    <label><input type="radio" name="timeFormat" value="24" ${is24HourFormat  ? 'checked' : ''}> 24 hours</label>
                </td>
            `;

            // Lap Time Format
            let lastLapTimeFormatRow = settingsBody.insertRow();
            lastLapTimeFormatRow.innerHTML = `
                <td>Last Lap Time Format</td>
                <td>
                    <label><input type="radio" name="lastLapTimeFormat" value="absolute" ${lastLapAbsoluteFormat  ? 'checked' : ''}> Absolute</label>
                    <label><input type="radio" name="lastLapTimeFormat" value="relative" ${!lastLapAbsoluteFormat ? 'checked' : ''}> Relative</label>
                </td>
            `;

            // Best Lap Time Format
            let bestLapTimeFormatRow = settingsBody.insertRow();
            bestLapTimeFormatRow.innerHTML = `
                <td>Best Lap Time Format</td>
                <td>
                    <label><input type="radio" name="bestLapTimeFormat" value="absolute" ${bestLapAbsoluteFormat  ? 'checked' : ''}> Absolute</label>
                    <label><input type="radio" name="bestLapTimeFormat" value="relative" ${!bestLapAbsoluteFormat ? 'checked' : ''}> Relative</label>
                </td>
            `;

            // Tyre Wear Format
            let tyreWearFormatRow = settingsBody.insertRow();
            tyreWearFormatRow.innerHTML = `
                <td>Tyre Wear Format</td>
                <td>
                    <label><input type="radio" name="tyreWearFormat" value="average" ${tyreWearAverageFormat  ? 'checked' : ''}> Average</label>
                    <label><input type="radio" name="tyreWearFormat" value="max" ${!tyreWearAverageFormat  ? 'checked' : ''}> Max</label>
                </td>
            `;

            // Append the table to the settingsDiv
            settingsDiv.appendChild(settingsTable);

            // Apply Button
            const applyButton = document.createElement('button');
            applyButton.innerText = 'Apply';
            applyButton.classList.add('apply-button');
            applyButton.onclick = function() {
                // Collect and log the selected settings
                myTeamName = document.getElementById('teamNameInput').value;
                is24HourFormat = (document.querySelector('input[name="timeFormat"]:checked').value === "24") ? (true) : (false);
                lastLapAbsoluteFormat = (document.querySelector('input[name="lastLapTimeFormat"]:checked').value === "absolute") ? (true) : (false);
                bestLapAbsoluteFormat = (document.querySelector('input[name="bestLapTimeFormat"]:checked').value === "absolute") ? (true) : (false);
                tyreWearAverageFormat = (document.querySelector('input[name="tyreWearFormat"]:checked').value === "average") ? (true) : (false);

                console.log("Settings Applied:", { myTeamName, is24HourFormat, lastLapAbsoluteFormat, bestLapAbsoluteFormat, tyreWearAverageFormat });
                showToast("Settings applied and saved!");
                savePreferences();
            };
            settingsDiv.appendChild(applyButton);

            // Finalize modal content
            const modalTitle = document.getElementById('modalTitle');
            modalTitle.innerText = `App Settings`;
            modalContent.appendChild(settingsDiv);

            const modal = document.getElementById('driverInfoModal');
            modal.style.display = 'block';
        }

        function formatSecondsToMMSS(seconds) {
            // Ensure the input is a number
            if (typeof seconds !== 'number' || seconds < 0) {
                throw new Error('Input should be a non-negative integer representing seconds.');
            }

            // Calculate minutes and remaining seconds
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;

            // Format minutes and seconds with leading zeros if necessary
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(remainingSeconds).padStart(2, '0');

            // Return formatted time string
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        function shouldShowSessionTimeLeft(eventType) {
            switch(eventType) {
                case "Practice 1":
                case "Practice 2":
                case "Practice 3":
                case "Short Practice":
                case "Qualifying 1":
                case "Qualifying 2":
                case "Qualifying 3":
                case "Short Qualifying":
                case "Sprint Shootout 1":
                case "Sprint Shootout 2":
                case "Sprint Shootout 3":
                case "Short Sprint Shootout":
                    return true;
                default:
                    return false;
            }
        }

        function updateGlobalInfo(circuit, event_type, track_temp, air_temp, curr_lap, total_laps,
            safety_car_status, fastest_lap, pit_speed_limit, sessionTimeLeft, packet_capture_enabled) {

            document.getElementById('tableTitle').textContent = `${event_type} - ${circuit}`;
            document.getElementById('trackTemperature').textContent = `${track_temp} °C`;
            document.getElementById('airTemperature').textContent = `${air_temp} °C`;
            if (total_laps === "---") {
                document.getElementById('lapInformation').textContent = `${curr_lap}`;
            } else {
                document.getElementById('lapInformation').textContent = `${curr_lap}/${total_laps}`;
            }
            document.getElementById('fastestLapOverall').textContent = `${formatLapTime(fastest_lap)}`;
            document.getElementById('pitSpeedLimit').textContent = `${pit_speed_limit} kmph`;

            let saveTelemetryLink = document.getElementById('saveTelemetryLinkRow');
            if (!packet_capture_enabled) {
                saveTelemetryLink.style.display = 'none';
            }

            let sessionTimeLeftRow = document.getElementById('sessionTimeLeftRow');
            if (shouldShowSessionTimeLeft(event_type)) {
                sessionTimeLeftRow.style.display = '';
                document.getElementById('sessionTimeLeft').textContent = `${formatSecondsToMMSS(sessionTimeLeft)}`;
            } else {
                sessionTimeLeftRow.style.display = 'none';
            }
        }

        function updateLocalTime() {
            const now = new Date();
            const options = {
                hour12: !is24HourFormat
            };
            const timeString = now.toLocaleTimeString('en-US', options);
            if (is24HourFormat) {
                document.getElementById('localTimeNameLink').textContent = `Local Time (24H)`;
            } else {
                document.getElementById('localTimeNameLink').textContent = `Local Time (12H)`;
            }
            document.getElementById('localTimeValueLink').textContent = `${timeString}`;
        }

        function toggleTimeFormat() {
            is24HourFormat = !is24HourFormat;
            updateLocalTime();
            showToast("Time Format Changed to " + (is24HourFormat ? "24 Hour Format" : "12 Hour Format"));
            savePreferences();
        }

        function toggleDeltaFormat() {
            relativeDelta = !relativeDelta;
            showToast("Delta Format Changed to " + (relativeDelta ? "Relative" : "Absolute"));
            savePreferences();
        }

        function toggleLastLapFormat() {
            lastLapAbsoluteFormat = !lastLapAbsoluteFormat;
            showToast("Last Lap Format Changed to " + (lastLapAbsoluteFormat ? "Absolute" : "Relative"));
            savePreferences();
        }

        function toggleBestLapFormat() {
            bestLapAbsoluteFormat = !bestLapAbsoluteFormat;
            showToast("Best Lap Format Changed to " + (bestLapAbsoluteFormat ? "Absolute" : "Relative"));
            savePreferences();
        }

        function toggleTyreWearFormat() {
            tyreWearAverageFormat = !tyreWearAverageFormat;
            showToast("Tyre wear format changed to " + (tyreWearAverageFormat ? "Average" : "Max"));
            savePreferences();
        }

        function formatFileSize(bytes) {
            const sizes = ['Bytes', 'kB', 'MB', 'GB', 'TB'];

            if (bytes === 0) return '0 Byte';

            const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
            const sizeUnit = sizes[Math.min(i, sizes.length - 1)];
            const formattedSize = Math.round((bytes / Math.pow(1024, i)) * 100) / 100;

            return `${formattedSize} ${sizeUnit}`;
        }

        document.getElementById("saveTelemetryLink").addEventListener("click", function () {
            fetch('/save-telemetry-capture')
                .then(response => response.json())
                .then(data => {
                    if (data['status-code'] === 'SUCCESS') {
                        const formattedFileSize = formatFileSize(data['num-bytes']);
                        const numPacketsWithCommas = data['num-packets'].toLocaleString();

                        Swal.fire({
                            icon: 'success',
                            title: 'Telemetry captured!',
                            html: `Written to file: ${data['file-name']}.<br>${numPacketsWithCommas} packets written.<br>File size: ${formattedFileSize}.`,
                        });
                    } else if (data['status-code'] === 'DISABLED') {
                        Swal.fire({
                            icon: 'info',
                            title: 'Telemetry capture is disabled!',
                            text: 'Please enable telemetry capture.',
                        });
                    } else {
                        if (data["num-packets"] === 0) {
                            Swal.fire({
                                icon: 'error',
                                title: 'Error capturing telemetry!',
                                text: 'There is no data available to write to file',
                            });
                        } else {
                            Swal.fire({
                                icon: 'error',
                                title: 'Error capturing telemetry!',
                                text: JSON.stringify(data),
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching telemetry capture details:', error);
                    Swal.fire({
                        icon: 'error',
                        title: 'Error fetching telemetry capture details!',
                        text: 'Please check the console for more information.',
                    });
                });
        });

        document.getElementById("getRaceInfo").addEventListener("click", function () {
            if ({{ live_data_mode | tojson | safe }}) {
                socket.emit('race-info', {'message' : 'dummy'});
            } else {
                fetch(`/race-info`)
                    .then(response => response.json())
                    .then(data => {
                        openRaceInfoModal(data);
                    })
                    .catch(error => {
                        console.error('Error fetching race info:', error);
                    });
            }
        });

        document.getElementById("settingsButton").addEventListener("click", function () {
            event.preventDefault();  // Prevent any default behavior that might interfere
            openSettingsModal();
        });

        function hideColumn(columnName) {
            var raceTable = document.getElementById("raceTable");
            var headers = raceTable.getElementsByTagName("th");

            // Find the Delta column header
            for (var i = 0; i < headers.length; i++) {
                if (headers[i].textContent === columnName) {
                    headers[i].style.display = hideColumn ? "none" : "";
                    break;
                }
            }
        }

        function getAdjacentPositions(position, total_cars, num_adjacent_cars) {
            if (!(1 <= position && position <= total_cars)) {
                return [];
            }

            let min_valid_lower_bound = 1;
            let max_valid_upper_bound = total_cars;

            // In time trial, total_cars will be lower than num_adjacent_cars
            if (num_adjacent_cars >= total_cars) {
                num_adjacent_cars = total_cars;
                var lower_bound = min_valid_lower_bound;
                var upper_bound = max_valid_upper_bound;
            }
            // GP scenario, lower bound and upper bound are off input position by num_adjacent_cars
            else {
                var lower_bound = position - num_adjacent_cars;
                var upper_bound = position + num_adjacent_cars;
            }

            // now correct if lower and upper bounds have become invalid
            if (lower_bound < min_valid_lower_bound) {
                // lower bound is negative, need to shift the entire window right
                upper_bound += min_valid_lower_bound - lower_bound;
                lower_bound = min_valid_lower_bound;
            }
            if (upper_bound > total_cars) {
                // upper bound is greater than limit, need to shift the entire window left
                lower_bound = lower_bound - (upper_bound - total_cars);
                upper_bound = max_valid_upper_bound;
            }

            return Array.from({ length: upper_bound - lower_bound + 1 }, (_, i) => lower_bound + i);
        }

        // Add an event listener to the hyperlink
        document.getElementById('localTimeNameLink').addEventListener('click', toggleTimeFormat);
        document.getElementById('localTimeValueLink').addEventListener('click', toggleTimeFormat);
        document.getElementById('deltaLink').addEventListener('click', toggleDeltaFormat);
        document.getElementById('lastLapLink').addEventListener('click', toggleLastLapFormat);
        document.getElementById('bestLapLink').addEventListener('click', toggleBestLapFormat);
        document.getElementById('tyreInfoLink').addEventListener('click', toggleTyreWearFormat);
        document.getElementById('wearPredictionLink').addEventListener('click', toggleTyreWearFormat);

        // Fetch data at intervals specified from jinja
        if (!{{ live_data_mode | tojson | safe }}) {
            setInterval(fetchDataAndDisplay, {{ client_poll_interval_ms | tojson | safe }});
            // Initial fetch and display
            fetchDataAndDisplay();
        }

        // Update local time every second
        setInterval(updateLocalTime, 1000);
        updateLocalTime();

        if (shouldHideDeltaColumn) {
            hideColumn("Delta");
        }
        if (shouldHidePredictionColumn) {
            hideColumn("Wear Prediction");
        }
        if (shouldHideFuelColumn) {
            hideColumn("Fuel Rates");
        }
        if (shouldHideLastLapColumn) {
            hideColumn("Last");
        }

        function loadPreferences() {
            let missingPreference = false;

            // Load or assign default values, and track if any value is missing
            if (localStorage.getItem('is24HourFormat') !== null) {
                is24HourFormat = localStorage.getItem('is24HourFormat') === 'true';
            } else {
                is24HourFormat = true;
                missingPreference = true;
            }

            if (localStorage.getItem('relativeDelta') !== null) {
                relativeDelta = localStorage.getItem('relativeDelta') === 'true';
            } else {
                relativeDelta = false;
                missingPreference = true;
            }

            if (localStorage.getItem('lastLapAbsoluteFormat') !== null) {
                lastLapAbsoluteFormat = localStorage.getItem('lastLapAbsoluteFormat') === 'true';
            } else {
                lastLapAbsoluteFormat = false;
                missingPreference = true;
            }

            if (localStorage.getItem('bestLapAbsoluteFormat') !== null) {
                bestLapAbsoluteFormat = localStorage.getItem('bestLapAbsoluteFormat') === 'true';
            } else {
                bestLapAbsoluteFormat = true;
                missingPreference = true;
            }

            if (localStorage.getItem('tyreWearAverageFormat') !== null) {
                tyreWearAverageFormat = localStorage.getItem('tyreWearAverageFormat') === 'true';
            } else {
                tyreWearAverageFormat = false;
                missingPreference = true;
            }

            myTeamName = localStorage.getItem('myTeamName');
            if ((myTeamName === null) || (myTeamName === "")) {
                myTeamName = "Custom Team";
                missingPreference = true;
            }

            // If any preference was missing, save all current preferences
            if (missingPreference) {
                savePreferences();
            }

            console.log("Loaded Preferences:", { myTeamName, is24HourFormat, lastLapAbsoluteFormat, bestLapAbsoluteFormat, tyreWearAverageFormat, relativeDelta });
        }

        function savePreferences() {
            localStorage.setItem('is24HourFormat', is24HourFormat);
            localStorage.setItem('relativeDelta', relativeDelta);
            localStorage.setItem('lastLapAbsoluteFormat', lastLapAbsoluteFormat);
            localStorage.setItem('bestLapAbsoluteFormat', bestLapAbsoluteFormat);
            localStorage.setItem('tyreWearAverageFormat', tyreWearAverageFormat);
            localStorage.setItem('myTeamName', myTeamName);

            console.log("Saved Preferences:", { myTeamName, is24HourFormat, lastLapAbsoluteFormat, bestLapAbsoluteFormat, tyreWearAverageFormat, relativeDelta });
        }

        // Load preferences on page load
        window.onload = function() {
            loadPreferences();
        };


        var socket = io.connect('http://' + document.domain + ':' + location.port, {
            reconnection: true,           // Enables reconnection
            reconnectionAttempts: Infinity, // Number of attempts before giving up (Infinity means never stop trying)
            reconnectionDelay: 1000,      // Initial delay before reconnection (in ms)
            reconnectionDelayMax: 5000,   // Maximum delay between reconnections (in ms)
            randomizationFactor: 0.5,     // Randomization factor to prevent reconnection storms
            timeout: 20000                // Connection timeout before giving up (in ms)
        });

        socket.on('connect', function () {
            socket.emit('register-client', { type: 'race-table' });
        });

        // Receive details from server
        socket.on('race-table-update', function (data) {
            displayData(data);
        });

        socket.on('race-info-response', function (data) {
            if (!('error' in data)) {
                openRaceInfoModal(data);
            } else {
                console.log("Received error for race-info request", data);
            }
        });

        socket.on('driver-info-response', function (data) {
            if (!('error' in data)) {
                openDriverInfoModal(data);
            } else {
                console.log("Received error for driver-info request", data);
            }
        });


    </script>
</body>

</html>